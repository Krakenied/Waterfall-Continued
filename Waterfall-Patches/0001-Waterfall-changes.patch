From 67c74c925d655bb70a0c5b9807ee988798f74426 Mon Sep 17 00:00:00 2001
From: Krakenied <Krakenied1@gmail.com>
Date: Fri, 9 Aug 2024 00:18:08 +0200
Subject: [PATCH] Waterfall changes

MIT License

Copyright (c) 2015-2016 Waterfall Team

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

diff --git a/api/pom.xml b/api/pom.xml
index 57c96a42..00537b66 100644
--- a/api/pom.xml
+++ b/api/pom.xml
@@ -4,42 +4,42 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-parent</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-parent</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-api</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-api</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
-    <name>BungeeCord-API</name>
+    <name>Waterfall-API</name>
     <description>API implemented by the Elastic Portal Suite</description>
 
     <dependencies>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-chat</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-chat</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-config</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-config</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-event</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-event</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-protocol</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-protocol</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/QueryResult.java b/api/src/main/java/io/github/waterfallmc/waterfall/QueryResult.java
new file mode 100644
index 00000000..9a262c8a
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/QueryResult.java
@@ -0,0 +1,59 @@
+package io.github.waterfallmc.waterfall;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NonNull;
+
+import java.util.List;
+
+@Data
+@AllArgsConstructor
+public class QueryResult {
+    /**
+     * The message of the day to return.
+     */
+    @NonNull
+    private String motd;
+    /**
+     * The game type to return, usually SMP.
+     */
+    @NonNull
+    private String gameType;
+    /**
+     * The world name to return.
+     */
+    @NonNull
+    private String worldName;
+    /**
+     * The number of players currently online.
+     */
+    private int onlinePlayers;
+    /**
+     * The maximum number of players that can be online.
+     */
+    private int maxPlayers;
+    /**
+     * The port for this server.
+     */
+    private int port;
+    /**
+     * The hostname for this server.
+     */
+    @NonNull
+    private String address;
+    /**
+     * The game ID for this server, usually MINECRAFT.
+     */
+    @NonNull
+    private String gameId;
+    /**
+     * The players currently online.
+     */
+    @NonNull
+    private final List<String> players;
+    /**
+     * The version to return for this server.
+     */
+    @NonNull
+    private String version;
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/event/ConnectionInitEvent.java b/api/src/main/java/io/github/waterfallmc/waterfall/event/ConnectionInitEvent.java
new file mode 100644
index 00000000..6e79675f
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/event/ConnectionInitEvent.java
@@ -0,0 +1,56 @@
+package io.github.waterfallmc.waterfall.event;
+
+import net.md_5.bungee.api.Callback;
+import net.md_5.bungee.api.config.ListenerInfo;
+import net.md_5.bungee.api.event.AsyncEvent;
+import net.md_5.bungee.api.event.ClientConnectEvent;
+import net.md_5.bungee.api.plugin.Cancellable;
+
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+
+import lombok.ToString;
+
+/**
+ * Represents a brand new connection made to the proxy, allowing for plugins to
+ * efficiently close a connection, useful for connection throttlers, etc
+ */
+@ToString
+public class ConnectionInitEvent extends AsyncEvent<ConnectionInitEvent> implements Cancellable {
+
+    private final SocketAddress remoteAddress;
+    private final ListenerInfo listener;
+    private boolean isCancelled = false;
+
+    public ConnectionInitEvent(SocketAddress remoteAddress, ListenerInfo listener, Callback<ConnectionInitEvent> done) {
+        super(done);
+        this.remoteAddress = remoteAddress;
+        this.listener = listener;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return this.isCancelled;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel) {
+        this.isCancelled = cancel;
+    }
+
+    /**
+     * @return the INetSocketAddress of the connection being opened
+     * @deprecated BungeeCord can accept connections via Unix domain sockets
+     */
+    @Deprecated
+    public InetSocketAddress getRemoteAddress() {
+        return (InetSocketAddress) remoteAddress;
+    }
+
+    /**
+     * @return the SocketAddress of the connection being opened
+     */
+    public SocketAddress getRemoteSocketAddress() {
+        return remoteAddress;
+    }
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/event/ProxyDefineCommandsEvent.java b/api/src/main/java/io/github/waterfallmc/waterfall/event/ProxyDefineCommandsEvent.java
new file mode 100644
index 00000000..1fd4fc90
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/event/ProxyDefineCommandsEvent.java
@@ -0,0 +1,41 @@
+package io.github.waterfallmc.waterfall.event;
+
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.connection.Connection;
+import net.md_5.bungee.api.connection.ProxiedPlayer;
+import net.md_5.bungee.api.event.TargetedEvent;
+import net.md_5.bungee.api.plugin.Command;
+import net.md_5.bungee.api.plugin.Event;
+
+import java.util.Map;
+
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.ToString;
+
+/**
+ * Called when the proxy intercepts the command packet
+ * allowing for plugins to prevent commands being added
+ * to the clients which might not be wanted.
+ *
+ *
+ * <i>Plugin developers, please implement {@link Command#hasPermission(CommandSender)}
+ * properly in favor of this event.</i>
+ */
+@Data
+@ToString(callSuper = true)
+@EqualsAndHashCode(callSuper = true)
+public class ProxyDefineCommandsEvent extends TargetedEvent {
+
+
+    /**
+     * The map of commands to be sent to the player
+     */
+    private final Map<String, Command> commands;
+
+    public ProxyDefineCommandsEvent(Connection sender, Connection receiver, Map<String, Command> commands) {
+        super(sender, receiver);
+        this.commands = commands;
+    }
+
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/event/ProxyExceptionEvent.java b/api/src/main/java/io/github/waterfallmc/waterfall/event/ProxyExceptionEvent.java
new file mode 100644
index 00000000..ee6cb5dd
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/event/ProxyExceptionEvent.java
@@ -0,0 +1,27 @@
+package io.github.waterfallmc.waterfall.event;
+
+import com.google.common.base.Preconditions;
+import io.github.waterfallmc.waterfall.exception.ProxyException;
+import net.md_5.bungee.api.plugin.Event;
+
+/**
+ * Called whenever an exception is thrown in a recoverable section of the server.
+ */
+public class ProxyExceptionEvent extends Event {
+
+    private ProxyException exception;
+
+    public ProxyExceptionEvent(ProxyException exception) {
+        this.exception = Preconditions.checkNotNull(exception, "exception");
+    }
+
+    /**
+     * Gets the wrapped exception that was thrown.
+     *
+     * @return Exception thrown
+     */
+    public ProxyException getException() {
+        return exception;
+    }
+
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/event/ProxyQueryEvent.java b/api/src/main/java/io/github/waterfallmc/waterfall/event/ProxyQueryEvent.java
new file mode 100644
index 00000000..220d59f0
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/event/ProxyQueryEvent.java
@@ -0,0 +1,28 @@
+package io.github.waterfallmc.waterfall.event;
+
+import io.github.waterfallmc.waterfall.QueryResult;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NonNull;
+import net.md_5.bungee.api.config.ListenerInfo;
+import net.md_5.bungee.api.plugin.Event;
+
+/**
+ * This event will be posted whenever a Query request is received.
+ */
+@AllArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+@Data
+public class ProxyQueryEvent extends Event {
+    /**
+     * The listener associated with this query.
+     */
+    @NonNull
+    private final ListenerInfo listener;
+    /**
+     * The query to return.
+     */
+    @NonNull
+    private QueryResult result;
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyCommandException.java b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyCommandException.java
new file mode 100644
index 00000000..644a4cd6
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyCommandException.java
@@ -0,0 +1,64 @@
+package io.github.waterfallmc.waterfall.exception;
+
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.plugin.Command;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Thrown when a command throws an exception
+ */
+public class ProxyCommandException extends ProxyException {
+
+    private final Command command;
+    private final CommandSender commandSender;
+    private final String[] arguments;
+
+    public ProxyCommandException(String message, Throwable cause, Command command, CommandSender commandSender, String[] arguments) {
+        super(message, cause);
+        this.commandSender = checkNotNull(commandSender, "commandSender");
+        this.arguments = checkNotNull(arguments, "arguments");
+        this.command = checkNotNull(command, "command");
+    }
+
+    public ProxyCommandException(Throwable cause, Command command, CommandSender commandSender, String[] arguments) {
+        super(cause);
+        this.commandSender = checkNotNull(commandSender, "commandSender");
+        this.arguments = checkNotNull(arguments, "arguments");
+        this.command = checkNotNull(command, "command");
+    }
+
+    protected ProxyCommandException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace, Command command, CommandSender commandSender, String[] arguments) {
+        super(message, cause, enableSuppression, writableStackTrace);
+        this.commandSender = checkNotNull(commandSender, "commandSender");
+        this.arguments = checkNotNull(arguments, "arguments");
+        this.command = checkNotNull(command, "command");
+    }
+
+    /**
+     * Gets the command which threw the exception
+     *
+     * @return exception throwing command
+     */
+    public Command getCommand() {
+        return command;
+    }
+
+    /**
+     * Gets the command sender which executed the command request
+     *
+     * @return command sender of exception thrown command request
+     */
+    public CommandSender getCommandSender() {
+        return commandSender;
+    }
+
+    /**
+     * Gets the arguments which threw the exception for the command
+     *
+     * @return arguments of exception thrown command request
+     */
+    public String[] getArguments() {
+        return arguments;
+    }
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyEventException.java b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyEventException.java
new file mode 100644
index 00000000..b9842dc5
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyEventException.java
@@ -0,0 +1,53 @@
+package io.github.waterfallmc.waterfall.exception;
+
+import net.md_5.bungee.api.plugin.Event;
+import net.md_5.bungee.api.plugin.Listener;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Exception thrown when a server event listener throws an exception
+ */
+//TODO Find a better way to retrieve the plugin for this. Currently the event register/bake process
+// doesnt leave a reference to the plugin so there's no way to know what one is being used at any given time
+public class ProxyEventException extends ProxyException {
+
+    private final Listener listener;
+    private final Event event;
+
+    public ProxyEventException(String message, Throwable cause, Listener listener, Event event) {
+        super(message, cause);
+        this.listener = checkNotNull(listener, "listener");
+        this.event = checkNotNull(event, "event");
+    }
+
+    public ProxyEventException(Throwable cause, Listener listener, Event event) {
+        super(cause);
+        this.listener = checkNotNull(listener, "listener");
+        this.event = checkNotNull(event, "event");
+    }
+
+    protected ProxyEventException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace, Listener listener, Event event) {
+        super(message, cause, enableSuppression, writableStackTrace);
+        this.listener = checkNotNull(listener, "listener");
+        this.event = checkNotNull(event, "event");
+    }
+
+    /**
+     * Gets the listener which threw the exception
+     *
+     * @return event listener
+     */
+    public Listener getListener() {
+        return listener;
+    }
+
+    /**
+     * Gets the event which caused the exception
+     *
+     * @return event
+     */
+    public Event getEvent() {
+        return event;
+    }
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyException.java b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyException.java
new file mode 100644
index 00000000..b9fbbbe8
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyException.java
@@ -0,0 +1,23 @@
+package io.github.waterfallmc.waterfall.exception;
+
+/**
+ * Wrapper exception for all exceptions that are thrown by the server.
+ */
+public class ProxyException extends Exception {
+
+    public ProxyException(String message) {
+        super(message);
+    }
+
+    public ProxyException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public ProxyException(Throwable cause) {
+        super(cause);
+    }
+
+    protected ProxyException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
+        super(message, cause, enableSuppression, writableStackTrace);
+    }
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyInternalException.java b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyInternalException.java
new file mode 100644
index 00000000..acc64c29
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyInternalException.java
@@ -0,0 +1,34 @@
+package io.github.waterfallmc.waterfall.exception;
+
+import io.github.waterfallmc.waterfall.event.ProxyExceptionEvent;
+import net.md_5.bungee.api.ProxyServer;
+
+/**
+ * Thrown when the internal server throws a recoverable exception.
+ */
+public class ProxyInternalException extends ProxyException {
+
+    public ProxyInternalException(String message) {
+        super(message);
+    }
+
+    public ProxyInternalException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public ProxyInternalException(Throwable cause) {
+        super(cause);
+    }
+
+    protected ProxyInternalException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
+        super(message, cause, enableSuppression, writableStackTrace);
+    }
+
+    public static void reportInternalException(Throwable cause) {
+        try {
+            ProxyServer.getInstance().getPluginManager().callEvent(new ProxyExceptionEvent(new ProxyInternalException(cause)));;
+        } catch (Throwable t) {
+            t.printStackTrace(); // Don't want to rethrow!
+        }
+    }
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyPluginEnableDisableException.java b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyPluginEnableDisableException.java
new file mode 100644
index 00000000..54dc7da0
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyPluginEnableDisableException.java
@@ -0,0 +1,20 @@
+package io.github.waterfallmc.waterfall.exception;
+
+import net.md_5.bungee.api.plugin.Plugin;
+
+/**
+ * Thrown whenever there is an exception with any enabling or disabling of plugins.
+ */
+public class ProxyPluginEnableDisableException extends ProxyPluginException {
+    public ProxyPluginEnableDisableException(String message, Throwable cause, Plugin responsiblePlugin) {
+        super(message, cause, responsiblePlugin);
+    }
+
+    public ProxyPluginEnableDisableException(Throwable cause, Plugin responsiblePlugin) {
+        super(cause, responsiblePlugin);
+    }
+
+    protected ProxyPluginEnableDisableException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace, Plugin responsiblePlugin) {
+        super(message, cause, enableSuppression, writableStackTrace, responsiblePlugin);
+    }
+}
\ No newline at end of file
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyPluginException.java b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyPluginException.java
new file mode 100644
index 00000000..b0de7a4b
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyPluginException.java
@@ -0,0 +1,36 @@
+package io.github.waterfallmc.waterfall.exception;
+
+import net.md_5.bungee.api.plugin.Plugin;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Wrapper exception for all cases to which a plugin can be immediately blamed for
+ */
+public class ProxyPluginException extends ProxyException {
+    public ProxyPluginException(String message, Throwable cause, Plugin responsiblePlugin) {
+        super(message, cause);
+        this.responsiblePlugin = checkNotNull(responsiblePlugin, "responsiblePlugin");
+    }
+
+    public ProxyPluginException(Throwable cause, Plugin responsiblePlugin) {
+        super(cause);
+        this.responsiblePlugin = checkNotNull(responsiblePlugin, "responsiblePlugin");
+    }
+
+    protected ProxyPluginException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace, Plugin responsiblePlugin) {
+        super(message, cause, enableSuppression, writableStackTrace);
+        this.responsiblePlugin = checkNotNull(responsiblePlugin, "responsiblePlugin");
+    }
+
+    private final Plugin responsiblePlugin;
+
+    /**
+     * Gets the plugin which is directly responsible for the exception being thrown
+     *
+     * @return plugin which is responsible for the exception throw
+     */
+    public Plugin getResponsiblePlugin() {
+        return responsiblePlugin;
+    }
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyPluginMessageException.java b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyPluginMessageException.java
new file mode 100644
index 00000000..9e24e09c
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyPluginMessageException.java
@@ -0,0 +1,64 @@
+package io.github.waterfallmc.waterfall.exception;
+
+import net.md_5.bungee.api.connection.ProxiedPlayer;
+import net.md_5.bungee.api.plugin.Plugin;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Thrown when an incoming plugin message channel throws an exception
+ */
+public class ProxyPluginMessageException extends ProxyPluginException {
+
+    private final ProxiedPlayer player;
+    private final String channel;
+    private final byte[] data;
+
+    public ProxyPluginMessageException(String message, Throwable cause, Plugin responsiblePlugin, ProxiedPlayer player, String channel, byte[] data) {
+        super(message, cause, responsiblePlugin);
+        this.player = checkNotNull(player, "player");
+        this.channel = checkNotNull(channel, "channel");
+        this.data = checkNotNull(data, "data");
+    }
+
+    public ProxyPluginMessageException(Throwable cause, Plugin responsiblePlugin, ProxiedPlayer player, String channel, byte[] data) {
+        super(cause, responsiblePlugin);
+        this.player = checkNotNull(player, "player");
+        this.channel = checkNotNull(channel, "channel");
+        this.data = checkNotNull(data, "data");
+    }
+
+    protected ProxyPluginMessageException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace, Plugin responsiblePlugin, ProxiedPlayer player, String channel, byte[] data) {
+        super(message, cause, enableSuppression, writableStackTrace, responsiblePlugin);
+        this.player = checkNotNull(player, "player");
+        this.channel = checkNotNull(channel, "channel");
+        this.data = checkNotNull(data, "data");
+    }
+
+    /**
+     * Gets the channel to which the error occurred from recieving data from
+     *
+     * @return exception channel
+     */
+    public String getChannel() {
+        return channel;
+    }
+
+    /**
+     * Gets the data to which the error occurred from
+     *
+     * @return exception data
+     */
+    public byte[] getData() {
+        return data;
+    }
+
+    /**
+     * Gets the player which the plugin message causing the exception originated from
+     *
+     * @return exception player
+     */
+    public ProxiedPlayer getPlayer() {
+        return player;
+    }
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxySchedulerException.java b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxySchedulerException.java
new file mode 100644
index 00000000..0d574ecc
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxySchedulerException.java
@@ -0,0 +1,37 @@
+package io.github.waterfallmc.waterfall.exception;
+
+import net.md_5.bungee.api.scheduler.ScheduledTask;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Thrown when a plugin's scheduler fails with an exception
+ */
+public class ProxySchedulerException extends ProxyPluginException {
+
+    private final ScheduledTask task;
+
+    public ProxySchedulerException(String message, Throwable cause, ScheduledTask task) {
+        super(message, cause, task.getOwner());
+        this.task = checkNotNull(task, "task");
+    }
+
+    public ProxySchedulerException(Throwable cause, ScheduledTask task) {
+        super(cause, task.getOwner());
+        this.task = checkNotNull(task, "task");
+    }
+
+    protected ProxySchedulerException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace, ScheduledTask task) {
+        super(message, cause, enableSuppression, writableStackTrace, task.getOwner());
+        this.task = checkNotNull(task, "task");
+    }
+
+    /**
+     * Gets the task which threw the exception
+     *
+     * @return exception throwing task
+     */
+    public ScheduledTask getTask() {
+        return task;
+    }
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyTabCompleteException.java b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyTabCompleteException.java
new file mode 100644
index 00000000..5bf57ec1
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/exception/ProxyTabCompleteException.java
@@ -0,0 +1,22 @@
+package io.github.waterfallmc.waterfall.exception;
+
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.plugin.Command;
+
+/**
+ * Called when a tab-complete request throws an exception
+ */
+public class ProxyTabCompleteException extends ProxyCommandException {
+
+    public ProxyTabCompleteException(String message, Throwable cause, Command command, CommandSender commandSender, String[] arguments) {
+        super(message, cause, command, commandSender, arguments);
+    }
+
+    public ProxyTabCompleteException(Throwable cause, Command command, CommandSender commandSender, String[] arguments) {
+        super(cause, command, commandSender, arguments);
+    }
+
+    protected ProxyTabCompleteException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace, Command command, CommandSender commandSender, String[] arguments) {
+        super(message, cause, enableSuppression, writableStackTrace, command, commandSender, arguments);
+    }
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/utils/FastException.java b/api/src/main/java/io/github/waterfallmc/waterfall/utils/FastException.java
new file mode 100644
index 00000000..11e103cb
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/utils/FastException.java
@@ -0,0 +1,19 @@
+package io.github.waterfallmc.waterfall.utils;
+
+// This is basically a copy of QuietException
+public class FastException extends RuntimeException {
+
+    public FastException(String message) {
+        super(message);
+    }
+
+    @Override
+    public synchronized Throwable initCause(Throwable cause) {
+        return this;
+    }
+
+    @Override
+    public synchronized Throwable fillInStackTrace() {
+        return this;
+    }
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/utils/Hex.java b/api/src/main/java/io/github/waterfallmc/waterfall/utils/Hex.java
new file mode 100644
index 00000000..4a169ebc
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/utils/Hex.java
@@ -0,0 +1,113 @@
+package io.github.waterfallmc.waterfall.utils;
+
+import java.util.Arrays;
+import java.util.Objects;
+
+public class Hex {
+
+    public static byte[] decode(CharSequence chars) {
+        byte[] bytes = new byte[chars.length() >> 1];
+        decode(chars, 0, bytes, 0, bytes.length);
+        return bytes;
+    }
+
+    public static void decode(char[] chars, int charOffset, byte[] dest, int offset, int length) {
+        decode(new CharSequence() {
+            @Override
+            public int length() {
+                return chars.length;
+            }
+
+            @Override
+            public char charAt(int index) {
+                return chars[index];
+            }
+
+            @Override
+            public CharSequence subSequence(int start, int end) {
+                return toString().substring(start, end);
+            }
+
+            @Override
+            public String toString() {
+                return new String(chars, charOffset, chars.length);
+            }
+        });
+    }
+
+    public static void decode(CharSequence chars, int charOffset, byte[] dest, int offset, int length) {
+        Objects.requireNonNull(chars, "Null chars");
+        Objects.requireNonNull(dest, "Null destination");
+        final int numChars = chars.length();
+        if ((numChars & 0x01) != 0) {
+            throw new IllegalArgumentException("Odd number of characters: " + numChars);
+        } else if (length < (numChars - charOffset) >> 1) {
+            throw new IllegalArgumentException("Too many bytes to fill with " + numChars + " characters: " + length);
+        } else if (offset < 0 || charOffset < 0 || length < 0 || length * 2 > numChars - charOffset || length > dest.length - offset) {
+            throw new IndexOutOfBoundsException();
+        }
+        for (int i = 0, charIndex = charOffset; i < length; i++) {
+            char first = chars.charAt(charIndex++);
+            char second = chars.charAt(charIndex++);
+            dest[i + offset] = (byte) ((toDigit(first) << 4) | (toDigit(second)));
+        }
+    }
+
+    public static String encodeString(byte[] bytes) {
+        return new String(encode(bytes));
+    }
+
+    public static char[] encode(byte[] bytes) {
+        char[] chars = new char[bytes.length << 1];
+        encode(chars, 0, bytes, 0, bytes.length);
+        return chars;
+    }
+
+    public static void encode(char[] chars, int charOffset, byte[] source, int offset, int length) {
+        Objects.requireNonNull(chars, "Null chars");
+        Objects.requireNonNull(source, "Null bytes");
+        if (offset < 0 || charOffset < 0 || length < 0 || length * 2 > chars.length - charOffset || length > source.length - offset) {
+            throw new IndexOutOfBoundsException();
+        } else if (length == 0) {
+            return;
+        }
+        for (int i = 0, charIndex = charOffset; i < length; i++) {
+            byte b = source[i + offset];
+            chars[charIndex++] = fromDigit((byte) ((b >> 4) & 0xF));
+            chars[charIndex++] = fromDigit((byte) (b & 0xF));
+        }
+    }
+    private static final char[] ENCODE_TABLE = new char[]{
+            '0', '1', '2', '3', '4', '5', '6', '7',
+            '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
+    };
+    private static final byte[] DECODE_TABLE = new byte[128];
+
+    static {
+        Arrays.fill(DECODE_TABLE, (byte) -1);
+        for (int value = 0; value < ENCODE_TABLE.length; value++) {
+            char c = ENCODE_TABLE[value];
+            DECODE_TABLE[c] = (byte) value;
+            char upper;
+            if ((upper = Character.toUpperCase(c)) != c) {
+                DECODE_TABLE[upper] = (byte) value;
+            }
+        }
+    }
+
+    public static byte toDigit(char c) {
+        byte value;
+        if (c < DECODE_TABLE.length) {
+            value = DECODE_TABLE[c];
+        } else {
+            value = -1;
+        }
+        if (value < 0) throw new IllegalArgumentException("Invalid character " + c);
+        return value;
+    }
+
+    private static char fromDigit(byte b) {
+        assert (b & 0xF) == b : "Out of range " + b;
+        return ENCODE_TABLE[b];
+    }
+}
diff --git a/api/src/main/java/io/github/waterfallmc/waterfall/utils/UUIDUtils.java b/api/src/main/java/io/github/waterfallmc/waterfall/utils/UUIDUtils.java
new file mode 100644
index 00000000..cc24dd35
--- /dev/null
+++ b/api/src/main/java/io/github/waterfallmc/waterfall/utils/UUIDUtils.java
@@ -0,0 +1,74 @@
+package io.github.waterfallmc.waterfall.utils;
+import java.util.UUID;
+
+import com.google.common.base.Preconditions;
+import com.google.common.primitives.Longs;
+
+public class UUIDUtils {
+    private UUIDUtils() {}
+
+    public static String undash(String id) {
+        return new StringBuilder( 32 ).append( id, 0, 8 ).append( id, 9, 13 ).append( id, 14, 18 ).append( id, 19, 23 ).append( id, 24, 36 ).toString();
+    }
+
+    public static String toMojangString(UUID id) {
+        Preconditions.checkNotNull(id, "Null id");
+        return Hex.encodeString(toBytes(id));
+    }
+
+    public static UUID fromString(String s) {
+        Preconditions.checkNotNull(s, "Null string");
+        if (s.length() == 36) { // UUID.toString() uuid
+            s = UUIDUtils.undash(s);
+        } else if (s.length() != 32) {
+            throw new IllegalArgumentException("Invalid UUID: " + s);
+        }
+        return fromMojangString0(s);
+    }
+
+    public static UUID fromMojangString(String s) {
+        Preconditions.checkNotNull(s, "Null string");
+        if (s.length() != 32) {
+            throw new IllegalArgumentException("UUID not in mojang format: " + s);
+        }
+        return fromMojangString0(s);
+    }
+
+    private static UUID fromMojangString0(String s) {
+        assert s != null : "Null string";
+        assert s.length() == 32 : "invalid length: " + s;
+        try {
+            return fromBytes(Hex.decode(s));
+        } catch (IllegalArgumentException e) {
+            throw new IllegalArgumentException("Invalid UUID: " + s);
+        }
+    }
+
+    public static byte[] toBytes(UUID id) {
+        Preconditions.checkNotNull(id, "Null id");
+        byte[] result = new byte[16];
+        long lsb = id.getLeastSignificantBits();
+        for (int i = 15; i >= 8; i--) {
+            result[i] = (byte) (lsb & 0xffL);
+            lsb >>= 8;
+        }
+        long msb = id.getMostSignificantBits();
+        for (int i = 7; i >= 0; i--) {
+            result[i] = (byte) (msb & 0xffL);
+            msb >>= 8;
+        }
+        return result;
+    }
+
+    public static UUID fromBytes(byte[] bytes) {
+        Preconditions.checkNotNull(bytes, "Null bytes");
+        if (bytes.length != 16) {
+            throw new IllegalArgumentException("Invalid length: " + bytes.length);
+        }
+        long msb = Longs.fromBytes(bytes[0], bytes[1], bytes[2], bytes[3],
+                bytes[4], bytes[5], bytes[6], bytes[7]);
+        long lsb = Longs.fromBytes(bytes[8], bytes[9], bytes[10], bytes[11],
+                bytes[12], bytes[13], bytes[14], bytes[15]);
+        return new UUID(msb, lsb);
+    }
+}
\ No newline at end of file
diff --git a/api/src/main/java/net/md_5/bungee/Util.java b/api/src/main/java/net/md_5/bungee/Util.java
index 6352951c..91efc0a6 100644
--- a/api/src/main/java/net/md_5/bungee/Util.java
+++ b/api/src/main/java/net/md_5/bungee/Util.java
@@ -3,6 +3,7 @@ package net.md_5.bungee;
 import com.google.common.base.Joiner;
 import com.google.common.primitives.UnsignedLongs;
 import io.netty.channel.unix.DomainSocketAddress;
+import com.google.common.primitives.Ints;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.net.URI;
@@ -10,6 +11,8 @@ import java.net.URISyntaxException;
 import java.util.Locale;
 import java.util.UUID;
 
+import io.github.waterfallmc.waterfall.utils.Hex;
+
 /**
  * Series of utility classes to perform various operations.
  */
@@ -66,7 +69,7 @@ public class Util
      */
     public static String hex(int i)
     {
-        return String.format( "0x%02X", i );
+        return Hex.encodeString(Ints.toByteArray(i));
     }
 
     /**
diff --git a/api/src/main/java/net/md_5/bungee/api/ProxyConfig.java b/api/src/main/java/net/md_5/bungee/api/ProxyConfig.java
index 2e41b4c4..469fe0e1 100644
--- a/api/src/main/java/net/md_5/bungee/api/ProxyConfig.java
+++ b/api/src/main/java/net/md_5/bungee/api/ProxyConfig.java
@@ -17,42 +17,124 @@ public interface ProxyConfig
     /**
      * Time before users are disconnected due to no network activity.
      *
-     * @return timeout
+     * @return the time before users are disconnected due to no network activity.
      */
     int getTimeout();
 
     /**
      * UUID used for metrics.
-     *
-     * @return uuid
+     * @return the UUID used for metrics
      */
     String getUuid();
 
     /**
      * Set of all listeners.
-     *
-     * @return listeners
+     * @return a set of all listeners
      */
     Collection<ListenerInfo> getListeners();
 
     /**
      * Set of all servers.
-     *
-     * @return servers
+     * @return a map of registered servers
+     * @deprecated The returned map may be modified concurrently by the proxy.
+     *             The safe alternative is {@link #getServersCopy()}.
      */
+    @Deprecated // Waterfall
     Map<String, ServerInfo> getServers();
 
+    // Waterfall start - Dynamic server addition/removal api
+    /**
+     * Return all servers registered to this proxy, keyed by name. The returned map
+     * is an immutable snapshot of the actual server collection. It cannot be modified,
+     * and it will not change.
+     *
+     * @return all registered remote server destinations
+     */
+    Map<String, ServerInfo> getServersCopy();
+
+    /**
+     * Gets the server info of a server.
+     *
+     * @param name the name of the configured server
+     * @return the server info belonging to the specified server
+     */
+    ServerInfo getServerInfo(String name);
+
+    /**
+     * Register the given server to the proxy.
+     * Any currently registered server with the same name will be replaced.
+     * This change is not saved to config.yml
+     *
+     * @param server The server to register with the proxy
+     *
+     * @return the previously registered server with the same name, or null if there was no such server.
+     */
+    ServerInfo addServer(ServerInfo server);
+
+    /**
+     * Register all of the given servers to the proxy.
+     * This change is not saved to config.yml
+     *
+     * @param servers The collection of servers to register with the proxy
+     *
+     * @return true if any servers were added or replaced.
+     */
+    boolean addServers(Collection<ServerInfo> servers);
+
+    /**
+     * Un-register the server with the given name from the proxy.
+     * This change is not saved to config.yml
+     *
+     * @param name The name of the server to unregister
+     *
+     * @return the server that was removed, or null if there is no server with the given name.
+     */
+    ServerInfo removeServerNamed(String name);
+
+    /**
+     * Un-register the given server from the proxy.
+     * The server is matched by name only, other fields in the given {@link ServerInfo} are ignored.
+     * This change is not saved to config.yml
+     *
+     * @param server the server to unregister from the proxy
+     *
+     * @return the server that was removed, or null if there is no server with a matching name.
+     */
+    ServerInfo removeServer(ServerInfo server);
+
+    /**
+     * Un-register servers with any of the given names from the proxy.
+     * This change is not saved to config.yml
+     *
+     * @param names a collection of server names to be unregistered
+     *
+     * @return true if any servers were removed.
+     */
+    boolean removeServersNamed(Collection<String> names);
+
+    /**
+     * Un-register all of the given servers from the proxy.
+     * The servers are matched by name only, other fields in the given {@link ServerInfo} are ignored.
+     * This change is not saved to config.yml
+     *
+     * @param servers a collection of servers to be unregistered
+     *
+     * @return true if any servers were removed.
+     */
+    boolean removeServers(Collection<ServerInfo> servers);
+    // Waterfall end
+
     /**
      * Does the server authenticate with Mojang.
      *
-     * @return online mode
+     * @return if the server authenticates to mojang
      */
     boolean isOnlineMode();
 
     /**
      * Whether proxy commands are logged to the proxy log.
      *
-     * @return log commands
+     * @return should the proxy log commands
      */
     boolean isLogCommands();
 
@@ -74,7 +156,7 @@ public interface ProxyConfig
     /**
      * A collection of disabled commands.
      *
-     * @return disabled commands
+     * @return a collection of disabled commands
      */
     Collection<String> getDisabledCommands();
 
@@ -97,15 +179,15 @@ public interface ProxyConfig
     /**
      * The connection throttle delay.
      *
-     * @return throttle
+     * @return the connection throttle delay
      */
     @Deprecated
     int getThrottle();
 
     /**
-     * Whether the proxy will parse IPs with spigot or not.
+     * Whether the proxy will forward the players information (UUID, IP)
      *
-     * @return ip forward
+     * @return should we forward player information
      */
     @Deprecated
     boolean isIpForward();
@@ -113,7 +195,7 @@ public interface ProxyConfig
     /**
      * The encoded favicon.
      *
-     * @return favicon
+     * @return the encoded favicon
      * @deprecated Use #getFaviconObject instead.
      */
     @Deprecated
@@ -122,7 +204,75 @@ public interface ProxyConfig
     /**
      * The favicon used for the server ping list.
      *
-     * @return favicon
+     * @return the favicon used for the server ping list
      */
     Favicon getFaviconObject();
+
+    //
+    // Waterfall Options
+    //
+
+    /**
+     * Whether we log InitialHandler connections
+     *
+     * @return whether we log InitialHandler connections
+     */
+    boolean isLogInitialHandlerConnections();
+
+    /**
+     * The supported versions
+     *
+     * @return the supported versions
+     */
+    String getGameVersion();
+
+    /**
+     * Whether Netty's async DNS resolver is used for account authentication.
+     *
+     * @return whether Netty's async DNS resolver is used for account authentication.
+     */
+    boolean isUseNettyDnsResolver();
+
+    // Throttling options
+
+    /**
+     * How often tab-complete packets can be sent.
+     * <br>
+     * Values in milliseconds.
+     *
+     * @return how often tab-complete packets can be sent in milliseconds
+     */
+    int getTabThrottle();
+
+    /**
+     * Should we disable the tab completion limit for 1.13+ clients
+     *
+     * @return should we disable the tab completion limit for 1.13+ clients
+     */
+    boolean isDisableModernTabLimiter();
+
+    /**
+     * @return Should we disable entity metadata rewriting?
+     */
+    boolean isDisableEntityMetadataRewrite();
+
+    /**
+     * Whether tablist rewriting should be disabled or not
+     * @return {@code true} if tablist rewriting is disabled, {@code false} otherwise
+     */
+    boolean isDisableTabListRewrite();
+
+    /**
+     * Gets the maximum number of registered plugin channels for any connection.
+     *
+     * @return the configured limit
+     */
+    int getPluginChannelLimit();
+
+    /**
+     * Gets the maximum length for any plugin message channel identifier.
+     *
+     * @return the configured limit
+     */
+    int getPluginChannelNameLimit();
 }
diff --git a/api/src/main/java/net/md_5/bungee/api/ProxyServer.java b/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
index 1f330bd2..a4011335 100644
--- a/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
+++ b/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
@@ -96,9 +96,25 @@ public abstract class ProxyServer
      * return a fresh map each time.
      *
      * @return all registered remote server destinations
+     *
+     * @deprecated The returned map is part of the proxy's internal state,
+     *             and may be modified concurrently by the proxy.
+     *             The safe alternative is {@link #getServersCopy()}.
      */
+    @Deprecated // Waterfall
     public abstract Map<String, ServerInfo> getServers();
 
+    // Waterfall begin - Cloned servers map
+    /**
+     * Return all servers registered to this proxy, keyed by name. The returned map
+     * is an immutable snapshot of the actual server collection. It cannot be modified,
+     * and it will not change.
+     *
+     * @return all registered remote server destinations
+     */
+    public abstract Map<String, ServerInfo> getServersCopy();
+    // Waterfall end
+
     /**
      * Gets the server info of a server.
      *
diff --git a/api/src/main/java/net/md_5/bungee/api/ServerConnectRequest.java b/api/src/main/java/net/md_5/bungee/api/ServerConnectRequest.java
index c81b0a4e..d21370be 100644
--- a/api/src/main/java/net/md_5/bungee/api/ServerConnectRequest.java
+++ b/api/src/main/java/net/md_5/bungee/api/ServerConnectRequest.java
@@ -68,6 +68,14 @@ public class ServerConnectRequest
      */
     @Setter
     private boolean retry;
+    // Waterfall start
+    /**
+     * Should feedback from the request be sent to players, allows plugins
+     * to silently deal with the outcome on their own
+     */
+    @Setter
+    private boolean sendFeedback;
+    // Waterfall end
 
     /**
      * Class that sets default properties/adds methods to the lombok builder
@@ -77,5 +85,6 @@ public class ServerConnectRequest
     {
 
         private int connectTimeout = ProxyServer.getInstance().getConfig().getServerConnectTimeout();
+        private boolean isSendFeedback = true; // Waterfall # God. f##king. lombok.
     }
 }
diff --git a/api/src/main/java/net/md_5/bungee/api/ServerPing.java b/api/src/main/java/net/md_5/bungee/api/ServerPing.java
index e582808f..29cd91dd 100644
--- a/api/src/main/java/net/md_5/bungee/api/ServerPing.java
+++ b/api/src/main/java/net/md_5/bungee/api/ServerPing.java
@@ -74,7 +74,7 @@ public class ServerPing
 
         public String getId()
         {
-            return uniqueId.toString().replace( "-", "" );
+            return io.github.waterfallmc.waterfall.utils.UUIDUtils.undash( uniqueId.toString() ); // Waterfall
         }
     }
 
diff --git a/api/src/main/java/net/md_5/bungee/api/connection/ProxiedPlayer.java b/api/src/main/java/net/md_5/bungee/api/connection/ProxiedPlayer.java
index 0fe647b8..32af4937 100644
--- a/api/src/main/java/net/md_5/bungee/api/connection/ProxiedPlayer.java
+++ b/api/src/main/java/net/md_5/bungee/api/connection/ProxiedPlayer.java
@@ -128,6 +128,38 @@ public interface ProxiedPlayer extends Connection, CommandSender
      */
     void connect(ServerInfo target, Callback<Boolean> callback);
 
+    // Waterfall start
+    /**
+     * Connects / transfers this user to the specified connection, gracefully
+     * closing the current one. Depending on the implementation, this method
+     * might return before the user has been connected.
+     *
+     * @param target the new server to connect to
+     * @param callback the method called when the connection is complete, or
+     * when an exception is encountered. The boolean parameter denotes success
+     * or failure.
+     * @param retry whether to retry the connection if the initial connection
+     *              fails.
+     */
+    void connect(ServerInfo target, Callback<Boolean> callback, boolean retry);
+
+    /**
+     * Connects / transfers this user to the specified connection, gracefully
+     * closing the current one. Depending on the implementation, this method
+     * might return before the user has been connected.
+     *
+     * @param target the new server to connect to
+     * @param callback the method called when the connection is complete, or
+     * when an exception is encountered. The boolean parameter denotes success
+     * or failure.
+     * @param retry whether to retry the connection if the initial connection
+     *              fails.
+     * @param timeout timeout in milliseconds of the connection created to the
+     *                target server
+     */
+    void connect(ServerInfo target, Callback<Boolean> callback, boolean retry, int timeout);
+    // Waterfall end
+
     /**
      * Connects / transfers this user to the specified connection, gracefully
      * closing the current one. Depending on the implementation, this method
@@ -141,6 +173,25 @@ public interface ProxiedPlayer extends Connection, CommandSender
      */
     void connect(ServerInfo target, Callback<Boolean> callback, ServerConnectEvent.Reason reason);
 
+    // Waterfall start
+    /**
+     * Connects / transfers this user to the specified connection, gracefully
+     * closing the current one. Depending on the implementation, this method
+     * might return before the user has been connected.
+     *
+     * @param target the new server to connect to
+     * @param callback the method called when the connection is complete, or
+     * when an exception is encountered. The boolean parameter denotes success
+     * or failure.
+     * @param retry whether to retry the connection if the initial connection
+     *              fails.
+     * @param reason the reason for connecting to the new server
+     * @param timeout timeout in milliseconds of the connection created to the
+     *                target server
+     */
+    void connect(ServerInfo target, Callback<Boolean> callback, boolean retry, ServerConnectEvent.Reason reason, int timeout);
+    // Waterfall end
+
     /**
      * Connects / transfers this user to the specified connection, gracefully
      * closing the current one. Depending on the implementation, this method
diff --git a/api/src/main/java/net/md_5/bungee/api/event/LoginEvent.java b/api/src/main/java/net/md_5/bungee/api/event/LoginEvent.java
index 4c09efff..46517e03 100644
--- a/api/src/main/java/net/md_5/bungee/api/event/LoginEvent.java
+++ b/api/src/main/java/net/md_5/bungee/api/event/LoginEvent.java
@@ -8,6 +8,7 @@ import net.md_5.bungee.api.chat.BaseComponent;
 import net.md_5.bungee.api.chat.TextComponent;
 import net.md_5.bungee.api.connection.PendingConnection;
 import net.md_5.bungee.api.plugin.Cancellable;
+import net.md_5.bungee.connection.LoginResult; // Waterfall: Parse LoginResult object to new constructor of LoginEvent
 
 /**
  * Event called to represent a player logging in.
@@ -26,6 +27,13 @@ public class LoginEvent extends AsyncEvent<LoginEvent> implements Cancellable
      * Message to use when kicking if this event is canceled.
      */
     private BaseComponent reason;
+    // Waterfall start - adding the LoginResult variable to provide access to it, when calling the login event
+    /**
+     * The player's login result containing his textures
+     */
+    private LoginResult loginResult;
+    // Waterfall end
+
     /**
      * Connection attempting to login.
      */
@@ -37,6 +45,15 @@ public class LoginEvent extends AsyncEvent<LoginEvent> implements Cancellable
         this.connection = connection;
     }
 
+    // Waterfall start - adding new constructor for LoginResult
+    public LoginEvent(PendingConnection connection, Callback<LoginEvent> done, LoginResult loginResult)
+    {
+        super( done );
+        this.connection = connection;
+        this.loginResult = loginResult;
+    }
+    // Waterfall end
+
     /**
      * @return reason to be displayed
      * @deprecated use component methods instead
diff --git a/api/src/main/java/net/md_5/bungee/api/event/ServerKickEvent.java b/api/src/main/java/net/md_5/bungee/api/event/ServerKickEvent.java
index 3f9efaa8..5d2597ad 100644
--- a/api/src/main/java/net/md_5/bungee/api/event/ServerKickEvent.java
+++ b/api/src/main/java/net/md_5/bungee/api/event/ServerKickEvent.java
@@ -44,6 +44,12 @@ public class ServerKickEvent extends Event implements Cancellable
      * State in which the kick occured.
      */
     private State state;
+    // Waterfall start
+    /**
+     * Circumstances which led to the kick.
+     */
+    private Cause cause;
+    // Waterfall end
 
     public enum State
     {
@@ -51,6 +57,13 @@ public class ServerKickEvent extends Event implements Cancellable
         CONNECTING, CONNECTED, UNKNOWN;
     }
 
+    // Waterfall start
+    public enum Cause
+    {
+        SERVER, LOST_CONNECTION, EXCEPTION, UNKNOWN;
+    }
+    // Waterfall end
+
     @Deprecated
     public ServerKickEvent(ProxiedPlayer player, BaseComponent[] kickReasonComponent, ServerInfo cancelServer)
     {
@@ -69,14 +82,29 @@ public class ServerKickEvent extends Event implements Cancellable
         this( player, kickedFrom, TextComponent.fromArray( kickReasonComponent ), cancelServer, state );
     }
 
-    public ServerKickEvent(ProxiedPlayer player, ServerInfo kickedFrom, BaseComponent reason, ServerInfo cancelServer, State state)
+    // Waterfall start
+
+    @Deprecated
+    public ServerKickEvent(ProxiedPlayer player, ServerInfo kickedFrom, BaseComponent kickReasonComponent, ServerInfo cancelServer, State state)
+    {
+        this(player, kickedFrom, kickReasonComponent, cancelServer, state, Cause.UNKNOWN);
+    }
+
+    public ServerKickEvent(ProxiedPlayer player, ServerInfo kickedFrom, BaseComponent[] reason, ServerInfo cancelServer, State state, Cause cause)
+    {
+        this(player, kickedFrom, TextComponent.fromArray(reason), cancelServer, state, cause);
+    }
+
+    public ServerKickEvent(ProxiedPlayer player, ServerInfo kickedFrom, BaseComponent reason, ServerInfo cancelServer, State state, Cause cause)
     {
         this.player = player;
         this.kickedFrom = kickedFrom;
         this.reason = reason;
         this.cancelServer = cancelServer;
         this.state = state;
+        this.cause = cause;
     }
+    // Waterfall end
 
     /**
      * @return the kick reason
diff --git a/api/src/main/java/net/md_5/bungee/api/plugin/Event.java b/api/src/main/java/net/md_5/bungee/api/plugin/Event.java
index e2e01ecb..25ec1bd8 100644
--- a/api/src/main/java/net/md_5/bungee/api/plugin/Event.java
+++ b/api/src/main/java/net/md_5/bungee/api/plugin/Event.java
@@ -12,4 +12,18 @@ public abstract class Event
     public void postCall()
     {
     }
+    // Waterfall start - Add callEvent() shortcut, borrowed from PaperMC/Paper
+    /**
+     * Calls the event and tests if cancelled.
+     *
+     * @return false if event was cancelled, if cancellable. otherwise true.
+     */
+    public final boolean callEvent() {
+        net.md_5.bungee.api.ProxyServer.getInstance().getPluginManager().callEvent(this);
+        if (this instanceof Cancellable) {
+            return !((Cancellable) this).isCancelled();
+        }
+        return true;
+    }
+    // Waterfall end
 }
diff --git a/api/src/main/java/net/md_5/bungee/api/plugin/Plugin.java b/api/src/main/java/net/md_5/bungee/api/plugin/Plugin.java
index 2286a1ab..3d1e9a3a 100644
--- a/api/src/main/java/net/md_5/bungee/api/plugin/Plugin.java
+++ b/api/src/main/java/net/md_5/bungee/api/plugin/Plugin.java
@@ -44,6 +44,13 @@ public class Plugin
         // init( proxy, description );
     }
 
+    // Waterfall start - Allow plugins to use SLF4J for logging
+    public org.slf4j.Logger getSLF4JLogger() {
+        return org.slf4j.LoggerFactory.getLogger(logger.getName());
+    }
+    // Waterfall end
+
+
     /**
      * Called when the plugin has just been loaded. Most of the proxy will not
      * be initialized, so only use it for registering
@@ -102,7 +109,7 @@ public class Plugin
         this.proxy = proxy;
         this.description = description;
         this.file = description.getFile();
-        this.logger = new PluginLogger( this );
+        this.logger = Logger.getLogger(description.getName()); // Waterfall - Handle plugin prefixes in implementation
     }
 
     //
diff --git a/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java b/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java
index a8b21559..1ba5b249 100644
--- a/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java
+++ b/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java
@@ -26,6 +26,11 @@ import java.util.Stack;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.logging.Level;
+import io.github.waterfallmc.waterfall.event.ProxyExceptionEvent; // Waterfall
+import io.github.waterfallmc.waterfall.exception.ProxyCommandException; // Waterfall
+import io.github.waterfallmc.waterfall.exception.ProxyEventException; // Waterfall
+import io.github.waterfallmc.waterfall.exception.ProxyPluginEnableDisableException; // Waterfall
+import io.github.waterfallmc.waterfall.exception.ProxyTabCompleteException; // Waterfall
 import lombok.RequiredArgsConstructor;
 import net.md_5.bungee.api.ChatColor;
 import net.md_5.bungee.api.CommandSender;
@@ -34,6 +39,7 @@ import net.md_5.bungee.api.connection.ProxiedPlayer;
 import net.md_5.bungee.event.EventBus;
 import net.md_5.bungee.event.EventHandler;
 import org.yaml.snakeyaml.LoaderOptions;
+import net.md_5.bungee.event.EventHandlerMethod; //Waterfall - Exception event
 import org.yaml.snakeyaml.Yaml;
 import org.yaml.snakeyaml.constructor.Constructor;
 import org.yaml.snakeyaml.introspector.PropertyUtils;
@@ -194,10 +200,9 @@ public final class PluginManager
         }
 
         String[] args = Arrays.copyOfRange( split, 1, split.length );
-        try
-        {
             if ( tabResults == null )
             {
+        try { // Waterfall - split command & tab complete exception handlers for exception event
                 if ( proxy.getConfig().isLogCommands() )
                 {
                     proxy.getLogger().log( Level.INFO, "{0} executed command: /{1}", new Object[]
@@ -206,21 +211,66 @@ public final class PluginManager
                     } );
                 }
                 command.execute( sender, args );
+        // Waterfall start - split command & tab complete exception handlers for exception event
+        } catch ( Exception ex ) {
+            sender.sendMessage( ChatColor.RED + "An internal error occurred whilst executing this command, please check the console log for details." );
+            ProxyServer.getInstance().getLogger().log( Level.WARNING, "Error in dispatching command", ex );
+            this.callEvent( new ProxyExceptionEvent( new ProxyCommandException( ex, command, sender, args ) ) ); //Waterfall - throw error event
+        }
+        // Waterfall end
             } else if ( commandLine.contains( " " ) && command instanceof TabExecutor )
             {
+        try { // Waterfall - split command & tab complete exception handlers for exception event
                 for ( String s : ( (TabExecutor) command ).onTabComplete( sender, args ) )
                 {
                     tabResults.add( s );
                 }
-            }
-        } catch ( Exception ex )
-        {
+        // Waterfall start - split command & tab complete exception handlers for exception event
+        } catch ( Exception ex ) {
             sender.sendMessage( ChatColor.RED + "An internal error occurred whilst executing this command, please check the console log for details." );
             ProxyServer.getInstance().getLogger().log( Level.WARNING, "Error in dispatching command", ex );
+            this.callEvent( new ProxyExceptionEvent( new ProxyTabCompleteException( ex, command, sender, args ) ) ); //Waterfall - throw error event
         }
+        // Waterfall end
+            }
         return true;
     }
 
+    // Waterfall start - Add method to tab-complete command names
+    /**
+     * Searches for tab-complete suggestions for the given command line.
+     *
+     * <p>This is similar to {@link #dispatchCommand(CommandSender, String, List)}
+     * called with a list, but it also handles completing the command names itself
+     * instead of just the arguments.</p>
+     *
+     * @param sender The command sender
+     * @param commandLine The current command line
+     * @return The tab-complete suggestions
+     */
+    public List<String> tabCompleteCommand(CommandSender sender, String commandLine) {
+        List<String> suggestions = new java.util.ArrayList<>();
+
+        if (commandLine.indexOf(' ') == -1) {
+            // Complete command name
+            for (Command command : this.commandMap.values()) {
+                if (command.getName().startsWith(commandLine)) {
+                    // Check command permissions before adding it to the suggestions
+                    String permission = command.getPermission();
+                    if (permission == null || permission.isEmpty() || sender.hasPermission(permission)) {
+                        suggestions.add(command.getName());
+                    }
+                }
+            }
+        } else {
+            // Complete command arguments
+            dispatchCommand(sender, commandLine, suggestions);
+        }
+
+        return suggestions;
+    }
+    // Waterfall end
+
     /**
      * Returns the {@link Plugin} objects corresponding to all loaded plugins.
      *
@@ -270,7 +320,11 @@ public final class PluginManager
                 } );
             } catch ( Throwable t )
             {
-                ProxyServer.getInstance().getLogger().log( Level.WARNING, "Exception encountered when loading plugin: " + plugin.getDescription().getName(), t );
+                // Waterfall start - throw exception event
+                String msg = "Exception encountered when loading plugin: " + plugin.getDescription().getName();
+                ProxyServer.getInstance().getLogger().log( Level.WARNING, msg, t );
+                this.callEvent( new ProxyExceptionEvent( new ProxyPluginEnableDisableException( msg, t, plugin) ) );
+                // Waterfall end
             }
         }
     }
@@ -410,7 +464,7 @@ public final class PluginManager
         Preconditions.checkNotNull( event, "event" );
 
         long start = System.nanoTime();
-        eventBus.post( event );
+        eventBus.post( event, this::handleEventException ); //Waterfall - pass exception handler below
         event.postCall();
 
         long elapsed = System.nanoTime() - start;
@@ -424,6 +478,14 @@ public final class PluginManager
         return event;
     }
 
+    //Waterfall start - Exception handler passed to event bus to fire the exception event
+    private <T extends Event> void handleEventException(String msg, T event, EventHandlerMethod method, Throwable ex) {
+        if( !(event instanceof ProxyExceptionEvent) ) {
+            this.callEvent( new ProxyExceptionEvent( new ProxyEventException( msg, ex, (Listener) method.getListener(), event) ) );
+        }
+    }
+    //Waterfall end
+
     /**
      * Register a {@link Listener} for receiving called events. Methods in this
      * Object which wish to receive events must be annotated with the
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/LoginResult.java b/api/src/main/java/net/md_5/bungee/connection/LoginResult.java
similarity index 100%
rename from proxy/src/main/java/net/md_5/bungee/connection/LoginResult.java
rename to api/src/main/java/net/md_5/bungee/connection/LoginResult.java
diff --git a/bootstrap/pom.xml b/bootstrap/pom.xml
index ff27b54e..a108e308 100644
--- a/bootstrap/pom.xml
+++ b/bootstrap/pom.xml
@@ -4,39 +4,40 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-parent</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-parent</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-bootstrap</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-bootstrap</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
-    <name>BungeeCord-Bootstrap</name>
-    <description>Java 1.6 loader for BungeeCord</description>
+    <name>Waterfall-Bootstrap</name>
+    <description>Java 1.6 loader for Waterfall</description>
 
     <properties>
         <maven.deploy.skip>true</maven.deploy.skip>
         <maven.javadoc.skip>true</maven.javadoc.skip>
-        <maven.compiler.source>1.6</maven.compiler.source>
-        <maven.compiler.target>1.6</maven.compiler.target>
+        <!-- use java 1.8, literally nobody is using 1.6-7 anymore, and, if they are, that's their own stupidity. -->
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
         <maven.build.timestamp.format>yyyyMMdd</maven.build.timestamp.format>
     </properties>
 
     <dependencies>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-proxy</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-proxy</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
     </dependencies>
 
     <build>
-        <finalName>BungeeCord</finalName>
+        <finalName>Waterfall</finalName>
         <plugins>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
@@ -45,9 +46,12 @@
                 <configuration>
                     <archive>
                         <manifestEntries>
-                            <Main-Class>net.md_5.bungee.Bootstrap</Main-Class> 
+                            <Main-Class>net.md_5.bungee.Bootstrap</Main-Class>
                             <Implementation-Version>${describe}</Implementation-Version>
                             <Specification-Version>${maven.build.timestamp}</Specification-Version>
+
+                            <!-- Log4j includes custom classes for Java 9+ (#293) -->
+                            <Multi-Release>true</Multi-Release>
                         </manifestEntries>
                     </archive>
                 </configuration>
@@ -75,7 +79,17 @@
                             </excludes>
                         </filter>
                     </filters>
+                    <transformers>
+                        <transformer implementation="com.github.edwgiz.maven_shade_plugin.log4j2_cache_transformer.PluginsCacheFileTransformer" />
+                    </transformers>
                 </configuration>
+                <dependencies>
+                    <dependency>
+                        <groupId>com.github.edwgiz</groupId>
+                        <artifactId>maven-shade-plugin.log4j2-cachefile-transformer</artifactId>
+                        <version>2.15</version>
+                    </dependency>
+                </dependencies>
             </plugin>
         </plugins>
     </build>
diff --git a/bootstrap/src/main/java/net/md_5/bungee/Bootstrap.java b/bootstrap/src/main/java/net/md_5/bungee/Bootstrap.java
index 6be22739..a4516ed9 100644
--- a/bootstrap/src/main/java/net/md_5/bungee/Bootstrap.java
+++ b/bootstrap/src/main/java/net/md_5/bungee/Bootstrap.java
@@ -7,7 +7,7 @@ public class Bootstrap
     {
         if ( Float.parseFloat( System.getProperty( "java.class.version" ) ) < 52.0 )
         {
-            System.err.println( "*** ERROR *** BungeeCord requires Java 8 or above to function! Please download and install it!" );
+            System.err.println( "*** ERROR *** Waterfall requires Java 8 or above to function! Please download and install it!" );
             System.out.println( "You can check your Java version with the command: java -version" );
             return;
         }
diff --git a/chat/pom.xml b/chat/pom.xml
index 71c4ce27..7db6020f 100644
--- a/chat/pom.xml
+++ b/chat/pom.xml
@@ -4,19 +4,19 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-parent</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-parent</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-chat</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-chat</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
-    <name>BungeeCord-Chat</name>
-    <description>Minecraft JSON chat API intended for use with BungeeCord</description>
+    <name>Waterfall-Chat</name>
+    <description>Minecraft JSON chat API intended for use with Waterfall</description>
 
     <dependencies>
         <dependency>
diff --git a/chat/src/test/java/net/md_5/bungee/api/chat/ComponentsTest.java b/chat/src/test/java/net/md_5/bungee/api/chat/ComponentsTest.java
index 2d8233e6..276322a8 100644
--- a/chat/src/test/java/net/md_5/bungee/api/chat/ComponentsTest.java
+++ b/chat/src/test/java/net/md_5/bungee/api/chat/ComponentsTest.java
@@ -673,6 +673,26 @@ public class ComponentsTest
         assertEquals( testClickEvent, extraGetter.apply( eventRetention, 1 ).getClickEvent() );
     }
 
+    @Test
+    public void testBuilderSpecialFormatting()
+    {
+        BaseComponent[] components = new ComponentBuilder( "Hello " )
+                .bold(true).underlined(true).italic(true).strikethrough(true).obfuscated(true)
+                .append("World").underlined(false).strikethrough(false).create();
+
+        assertTrue( components[0].isBold() );
+        assertTrue( components[0].isUnderlined() );
+        assertTrue( components[0].isItalic() );
+        assertTrue( components[0].isStrikethrough() );
+        assertTrue( components[0].isObfuscated() );
+
+        assertTrue( components[1].isBold() );
+        assertFalse( components[1].isUnderlined() );
+        assertTrue( components[1].isItalic() );
+        assertFalse( components[1].isStrikethrough() );
+        assertTrue( components[1].isObfuscated() );
+    }
+
     @Test
     public void testLoopSimple()
     {
diff --git a/chat/src/test/java/net/md_5/bungee/api/chat/TranslatableComponentTest.java b/chat/src/test/java/net/md_5/bungee/api/chat/TranslatableComponentTest.java
index 995c70f2..dd9f040d 100644
--- a/chat/src/test/java/net/md_5/bungee/api/chat/TranslatableComponentTest.java
+++ b/chat/src/test/java/net/md_5/bungee/api/chat/TranslatableComponentTest.java
@@ -48,4 +48,11 @@ public class TranslatableComponentTest
         assertEquals( "Buried Treasure Map", one_four_two.toPlainText() );
     }
 
+    @Test
+    public void testEscapedPercentInPlainText()
+    {
+        TranslatableComponent testComponent = new TranslatableComponent( "Test string with %% sign" );
+        assertEquals( "Test string with % sign", testComponent.toPlainText() );
+        assertEquals( "fTest string with f%f sign", testComponent.toLegacyText() );
+    }
 }
diff --git a/config/pom.xml b/config/pom.xml
index 4b94f112..d245a60b 100644
--- a/config/pom.xml
+++ b/config/pom.xml
@@ -4,19 +4,19 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-parent</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-parent</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-config</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-config</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
-    <name>BungeeCord-Config</name>
-    <description>Generic java configuration API intended for use with BungeeCord</description>
+    <name>Waterfall-Config</name>
+    <description>Generic java configuration API intended for use with Waterfall</description>
 
     <dependencies>
         <dependency>
diff --git a/config/src/main/java/net/md_5/bungee/config/Configuration.java b/config/src/main/java/net/md_5/bungee/config/Configuration.java
index 262b29c8..d7ed3e11 100644
--- a/config/src/main/java/net/md_5/bungee/config/Configuration.java
+++ b/config/src/main/java/net/md_5/bungee/config/Configuration.java
@@ -44,6 +44,13 @@ public final class Configuration
         }
     }
 
+    // Waterfall start - Allow configuration objects to be cloned
+    public Configuration(Configuration values, Configuration defaults)
+    {
+        this( values.self, defaults );
+    }
+    // Waterfall end
+
     private Configuration getSectionFor(String path)
     {
         int index = path.indexOf( SEPARATOR );
diff --git a/event/pom.xml b/event/pom.xml
index 84711f0f..2ac455cc 100644
--- a/event/pom.xml
+++ b/event/pom.xml
@@ -4,17 +4,17 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-parent</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-parent</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-event</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-event</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
-    <name>BungeeCord-Event</name>
-    <description>Generic java event dispatching API intended for use with BungeeCord</description>
+    <name>Waterfall-Event</name>
+    <description>Generic java event dispatching API intended for use with Waterfall.</description>
 </project>
diff --git a/event/src/main/java/net/md_5/bungee/event/EventBus.java b/event/src/main/java/net/md_5/bungee/event/EventBus.java
index fb301a44..1187acd0 100644
--- a/event/src/main/java/net/md_5/bungee/event/EventBus.java
+++ b/event/src/main/java/net/md_5/bungee/event/EventBus.java
@@ -34,7 +34,8 @@ public class EventBus
         this.logger = ( logger == null ) ? Logger.getLogger( Logger.GLOBAL_LOGGER_NAME ) : logger;
     }
 
-    public void post(Object event)
+    // Waterfall - Add generic to signature so we don't have to cast in exception handler
+    public <T> void post(T event, EventExceptionHandler<T> exceptionHandler)
     {
         EventHandlerMethod[] handlers = byEventBaked.get( event.getClass() );
 
@@ -55,7 +56,9 @@ public class EventBus
                     throw new Error( "Method rejected target/argument: " + event, ex );
                 } catch ( InvocationTargetException ex )
                 {
-                    logger.log( Level.WARNING, MessageFormat.format( "Error dispatching event {0} to listener {1}", event, method.getListener() ), ex.getCause() );
+                    String msg = MessageFormat.format( "Error dispatching event {0} to listener {1}", event, method.getListener() );
+                    logger.log( Level.WARNING, msg, ex.getCause() );
+                    if( exceptionHandler != null ) exceptionHandler.handleEventException( msg, event, method, ex ); //Waterfall - call passed exception handler
                 }
 
                 long elapsed = System.nanoTime() - start;
diff --git a/event/src/main/java/net/md_5/bungee/event/EventExceptionHandler.java b/event/src/main/java/net/md_5/bungee/event/EventExceptionHandler.java
new file mode 100644
index 00000000..088fe9b7
--- /dev/null
+++ b/event/src/main/java/net/md_5/bungee/event/EventExceptionHandler.java
@@ -0,0 +1,7 @@
+package net.md_5.bungee.event;
+
+public interface EventExceptionHandler<T> {
+
+    public void handleEventException(String msg, T event, EventHandlerMethod method, Throwable ex);
+
+}
diff --git a/event/src/test/java/net/md_5/bungee/event/EventBusTest.java b/event/src/test/java/net/md_5/bungee/event/EventBusTest.java
index da2aa05d..712da5ae 100644
--- a/event/src/test/java/net/md_5/bungee/event/EventBusTest.java
+++ b/event/src/test/java/net/md_5/bungee/event/EventBusTest.java
@@ -14,14 +14,14 @@ public class EventBusTest
     public void testNestedEvents()
     {
         bus.register( this );
-        bus.post( new FirstEvent() );
+        bus.post( new FirstEvent(), null ); // Waterfall - We dont need an exception handler here
         assertEquals( 0, latch.getCount() );
     }
 
     @EventHandler
     public void firstListener(FirstEvent event)
     {
-        bus.post( new SecondEvent() );
+        bus.post( new SecondEvent(), null ); // Waterfall - We dont need an exception handler here
         assertEquals( 1, latch.getCount() );
         latch.countDown();
     }
@@ -39,4 +39,5 @@ public class EventBusTest
     public static class SecondEvent
     {
     }
+
 }
diff --git a/event/src/test/java/net/md_5/bungee/event/EventPriorityTest.java b/event/src/test/java/net/md_5/bungee/event/EventPriorityTest.java
index 3c5d45ea..7467540a 100644
--- a/event/src/test/java/net/md_5/bungee/event/EventPriorityTest.java
+++ b/event/src/test/java/net/md_5/bungee/event/EventPriorityTest.java
@@ -15,7 +15,7 @@ public class EventPriorityTest
     {
         bus.register( this );
         bus.register( new EventPriorityListenerPartner() );
-        bus.post( new PriorityTestEvent() );
+        bus.post( new PriorityTestEvent(), null ); // Waterfall - We dont need an exception handler here
         assertEquals( 0, latch.getCount() );
     }
 
diff --git a/event/src/test/java/net/md_5/bungee/event/UnregisteringListenerTest.java b/event/src/test/java/net/md_5/bungee/event/UnregisteringListenerTest.java
index 014de202..40792a68 100644
--- a/event/src/test/java/net/md_5/bungee/event/UnregisteringListenerTest.java
+++ b/event/src/test/java/net/md_5/bungee/event/UnregisteringListenerTest.java
@@ -13,7 +13,7 @@ public class UnregisteringListenerTest
     {
         bus.register( this );
         bus.unregister( this );
-        bus.post( new TestEvent() );
+        bus.post( new TestEvent(), null ); // Waterfall - We dont need an exception handler here
     }
 
     @EventHandler
diff --git a/log/pom.xml b/log/pom.xml
index 0091af13..3851e6ce 100644
--- a/log/pom.xml
+++ b/log/pom.xml
@@ -4,19 +4,19 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-parent</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-parent</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-log</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-log</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
-    <name>BungeeCord-Log</name>
-    <description>Simplistic and performant java.util.Logger based logger and console API designed for use with BungeeCord and Minecraft related applications.</description>
+    <name>Waterfall-Log</name>
+    <description>Simplistic and performant java.util.Logger based logger and console API designed for use with Waterfall and Minecraft related applications.</description>
 
     <dependencies>
         <dependency>
@@ -26,8 +26,8 @@
             <scope>compile</scope>
         </dependency>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-chat</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-chat</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
diff --git a/log/src/main/java/net/md_5/bungee/log/LogDispatcher.java b/log/src/main/java/net/md_5/bungee/log/LogDispatcher.java
index f1ccd4f6..d703d6d2 100644
--- a/log/src/main/java/net/md_5/bungee/log/LogDispatcher.java
+++ b/log/src/main/java/net/md_5/bungee/log/LogDispatcher.java
@@ -12,7 +12,7 @@ public class LogDispatcher extends Thread
 
     public LogDispatcher(BungeeLogger logger)
     {
-        super( "BungeeCord Logger Thread" );
+        super( "Waterfall Logger Thread" );
         this.logger = logger;
     }
 
diff --git a/log4j/pom.xml b/log4j/pom.xml
new file mode 100644
index 00000000..81b360eb
--- /dev/null
+++ b/log4j/pom.xml
@@ -0,0 +1,66 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-parent</artifactId>
+        <version>1.21-R0.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
+
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-log4j</artifactId>
+    <version>1.21-R0.1-SNAPSHOT</version>
+    <packaging>jar</packaging>
+
+    <name>Waterfall-Log4J</name>
+    <description>Simplistic and performant Log4j2 based logger and console API designed for use with Waterfall and Minecraft related applications.</description>
+
+    <properties>
+        <log4j2.version>2.20.0</log4j2.version>
+    </properties>
+
+    <dependencies>
+        <!-- Log4j -->
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-core</artifactId>
+            <version>${log4j2.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-iostreams</artifactId>
+            <version>${log4j2.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-jul</artifactId>
+            <version>${log4j2.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <version>${log4j2.version}</version>
+            <scope>runtime</scope>
+            <exclusions>
+                <exclusion>
+                    <groupId>org.slf4j</groupId>
+                    <artifactId>slf4j-api</artifactId>
+                </exclusion>
+            </exclusions>
+        </dependency>
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-api</artifactId>
+            <version>1.7.36</version>
+            <scope>runtime</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.lmax</groupId>
+            <artifactId>disruptor</artifactId>
+            <version>3.4.4</version>
+            <scope>runtime</scope>
+        </dependency>
+    </dependencies>
+</project>
diff --git a/log4j/src/main/java/io/github/waterfallmc/waterfall/log4j/Log4JLogHandler.java b/log4j/src/main/java/io/github/waterfallmc/waterfall/log4j/Log4JLogHandler.java
new file mode 100644
index 00000000..63f66d3c
--- /dev/null
+++ b/log4j/src/main/java/io/github/waterfallmc/waterfall/log4j/Log4JLogHandler.java
@@ -0,0 +1,59 @@
+package io.github.waterfallmc.waterfall.log4j;
+
+import com.google.common.base.Strings;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.apache.logging.log4j.jul.LevelTranslator;
+import org.apache.logging.log4j.message.MessageFormatMessage;
+
+import java.util.Map;
+import java.util.MissingResourceException;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.logging.Handler;
+import java.util.logging.LogRecord;
+
+/**
+ * A {@link Handler} that forwards all log messages to the Log4J logger.
+ *
+ * <p>We don't use Log4J's custom JUL LogManager currently, because it breaks
+ * adding custom handlers to JUL loggers. Some plugins may depend on that
+ * functionality...</p>
+ */
+class Log4JLogHandler extends Handler {
+
+    private final Map<String, Logger> cache = new ConcurrentHashMap<>();
+
+    @Override
+    public void publish(LogRecord record) {
+        if (!isLoggable(record)) {
+            return;
+        }
+
+        Logger logger = cache.computeIfAbsent(Strings.nullToEmpty(record.getLoggerName()), LogManager::getLogger);
+
+        String message = record.getMessage();
+        if (record.getResourceBundle() != null) {
+            try {
+                message = record.getResourceBundle().getString(message);
+            } catch (MissingResourceException ignored) {
+            }
+        }
+
+        final Level level = LevelTranslator.toLevel(record.getLevel());
+        if (record.getParameters() != null && record.getParameters().length > 0) {
+            logger.log(level, new MessageFormatMessage(message, record.getParameters()), record.getThrown());
+        } else {
+            logger.log(level, message, record.getThrown());
+        }
+    }
+
+    @Override
+    public void flush() {
+    }
+
+    @Override
+    public void close() {
+    }
+
+}
diff --git a/log4j/src/main/java/io/github/waterfallmc/waterfall/log4j/WaterfallLogger.java b/log4j/src/main/java/io/github/waterfallmc/waterfall/log4j/WaterfallLogger.java
new file mode 100644
index 00000000..e046897a
--- /dev/null
+++ b/log4j/src/main/java/io/github/waterfallmc/waterfall/log4j/WaterfallLogger.java
@@ -0,0 +1,34 @@
+package io.github.waterfallmc.waterfall.log4j;
+
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.io.IoBuilder;
+import java.util.logging.Handler;
+import java.util.logging.Logger;
+
+public final class WaterfallLogger {
+
+    private WaterfallLogger() {
+    }
+
+    public static Logger create() {
+        org.apache.logging.log4j.Logger redirect = LogManager.getRootLogger();
+        System.setOut(IoBuilder.forLogger(redirect).setLevel(Level.INFO).buildPrintStream());
+        System.setErr(IoBuilder.forLogger(redirect).setLevel(Level.ERROR).buildPrintStream());
+
+        Logger root = Logger.getLogger("");
+        root.setUseParentHandlers(false);
+
+        // Remove existing handlers
+        for (Handler handler : root.getHandlers()) {
+            root.removeHandler(handler);
+        }
+
+        // Setup forward log handler
+        root.setLevel(java.util.logging.Level.ALL); // Log4j will handle filtering the log
+        root.addHandler(new Log4JLogHandler());
+
+        return Logger.getLogger("BungeeCord");
+    }
+
+}
diff --git a/log4j/src/main/resources/log4j2-bungee.xml b/log4j/src/main/resources/log4j2-bungee.xml
new file mode 100644
index 00000000..1c3265ed
--- /dev/null
+++ b/log4j/src/main/resources/log4j2-bungee.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- Log4j configuration that replicates the old BungeeCord logging setup -->
+<Configuration status="warn">
+    <Appenders>
+        <TerminalConsole name="TerminalConsole">
+            <PatternLayout>
+                <LoggerNamePatternSelector defaultPattern="%highlightError{%d{HH:mm:ss} [%level] [%logger] %paperMinecraftFormatting{%msg}%n%ex}">
+                    <!-- Log root and BungeeCord loggers without prefix -->
+                    <PatternMatch key=",BungeeCord" pattern="%highlightError{%d{HH:mm:ss} [%level] %paperMinecraftFormatting{%msg}%n%ex}" />
+                </LoggerNamePatternSelector>
+            </PatternLayout>
+        </TerminalConsole>
+        <RollingRandomAccessFile name="File" fileName="proxy.log.0" filePattern="proxy.log.%i" immediateFlush="false">
+            <PatternLayout>
+                <LoggerNamePatternSelector defaultPattern="%d{HH:mm:ss} [%level] [%logger] %paperMinecraftFormatting{%msg}{strip}%n%ex">
+                    <!-- Log root and BungeeCord loggers without prefix -->
+                    <PatternMatch key=",BungeeCord" pattern="%d{HH:mm:ss} [%level] %paperMinecraftFormatting{%msg}{strip}%n%ex" />
+                </LoggerNamePatternSelector>
+            </PatternLayout>
+            <Policies>
+                <OnStartupTriggeringPolicy />
+                <SizeBasedTriggeringPolicy size="8 MB" />
+            </Policies>
+            <DefaultRolloverStrategy fileIndex="min" max="8" />
+        </RollingRandomAccessFile>
+    </Appenders>
+
+    <Loggers>
+        <Root level="info">
+            <AppenderRef ref="TerminalConsole" />
+            <AppenderRef ref="File" />
+        </Root>
+    </Loggers>
+</Configuration>
diff --git a/log4j/src/main/resources/log4j2.component.properties b/log4j/src/main/resources/log4j2.component.properties
new file mode 100644
index 00000000..e43f5dac
--- /dev/null
+++ b/log4j/src/main/resources/log4j2.component.properties
@@ -0,0 +1,2 @@
+log4j2.contextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector
+log4j.skipJansi=true
diff --git a/log4j/src/main/resources/log4j2.xml b/log4j/src/main/resources/log4j2.xml
new file mode 100644
index 00000000..663bddec
--- /dev/null
+++ b/log4j/src/main/resources/log4j2.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Configuration status="warn" shutdownHook="disable">
+    <Appenders>
+        <TerminalConsole name="TerminalConsole">
+            <PatternLayout>
+                <LoggerNamePatternSelector defaultPattern="%highlightError{[%d{HH:mm:ss} %level] [%logger]: %paperMinecraftFormatting{%msg}%n%xEx}">
+                    <!-- Log root and BungeeCord loggers without prefix -->
+                    <PatternMatch key=",BungeeCord" pattern="%highlightError{[%d{HH:mm:ss} %level]: %paperMinecraftFormatting{%msg}%n%xEx}" />
+                </LoggerNamePatternSelector>
+            </PatternLayout>
+        </TerminalConsole>
+        <RollingRandomAccessFile name="File" fileName="logs/latest.log" filePattern="logs/%d{yyyy-MM-dd}-%i.log.gz" immediateFlush="false">
+            <PatternLayout>
+                <LoggerNamePatternSelector defaultPattern="[%d{HH:mm:ss}] [%t/%level] [%logger]: %paperMinecraftFormatting{%msg}{strip}%n">
+                    <!-- Log root and BungeeCord loggers without prefix -->
+                    <PatternMatch key=",BungeeCord" pattern="[%d{HH:mm:ss}] [%t/%level]: %paperMinecraftFormatting{%msg}{strip}%n" />
+                </LoggerNamePatternSelector>
+            </PatternLayout>
+            <Policies>
+                <TimeBasedTriggeringPolicy />
+                <OnStartupTriggeringPolicy />
+            </Policies>
+        </RollingRandomAccessFile>
+    </Appenders>
+
+    <Loggers>
+        <Root level="info">
+            <AppenderRef ref="TerminalConsole" />
+            <AppenderRef ref="File" />
+        </Root>
+    </Loggers>
+</Configuration>
diff --git a/module/cmd-alert/pom.xml b/module/cmd-alert/pom.xml
index fd6bb27e..07b901a3 100644
--- a/module/cmd-alert/pom.xml
+++ b/module/cmd-alert/pom.xml
@@ -4,14 +4,14 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-module</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-module</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-module-cmd-alert</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-module-cmd-alert</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
diff --git a/module/cmd-find/pom.xml b/module/cmd-find/pom.xml
index a679a54a..e3a8a06d 100644
--- a/module/cmd-find/pom.xml
+++ b/module/cmd-find/pom.xml
@@ -4,14 +4,14 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-module</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-module</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-module-cmd-find</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-module-cmd-find</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
diff --git a/module/cmd-kick/pom.xml b/module/cmd-kick/pom.xml
index 8f79be48..3a45cb54 100644
--- a/module/cmd-kick/pom.xml
+++ b/module/cmd-kick/pom.xml
@@ -4,14 +4,14 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-module</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-module</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-module-cmd-kick</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-module-cmd-kick</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
diff --git a/module/cmd-list/pom.xml b/module/cmd-list/pom.xml
index 39e7b998..933fc3ed 100644
--- a/module/cmd-list/pom.xml
+++ b/module/cmd-list/pom.xml
@@ -4,14 +4,14 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-module</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-module</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-module-cmd-list</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-module-cmd-list</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
diff --git a/module/cmd-send/pom.xml b/module/cmd-send/pom.xml
index fe51d004..6b3e2e87 100644
--- a/module/cmd-send/pom.xml
+++ b/module/cmd-send/pom.xml
@@ -4,14 +4,14 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-module</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-module</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-module-cmd-send</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-module-cmd-send</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
diff --git a/module/cmd-server/pom.xml b/module/cmd-server/pom.xml
index bc1409aa..45cca078 100644
--- a/module/cmd-server/pom.xml
+++ b/module/cmd-server/pom.xml
@@ -4,14 +4,14 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-module</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-module</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-module-cmd-server</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-module-cmd-server</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
diff --git a/module/cmd-server/src/main/java/net/md_5/bungee/module/cmd/server/CommandServer.java b/module/cmd-server/src/main/java/net/md_5/bungee/module/cmd/server/CommandServer.java
index 59c104d3..698b420f 100644
--- a/module/cmd-server/src/main/java/net/md_5/bungee/module/cmd/server/CommandServer.java
+++ b/module/cmd-server/src/main/java/net/md_5/bungee/module/cmd/server/CommandServer.java
@@ -83,7 +83,7 @@ public class CommandServer extends Command implements TabExecutor
     @Override
     public Iterable<String> onTabComplete(final CommandSender sender, final String[] args)
     {
-        return ( args.length > 1 ) ? Collections.EMPTY_LIST : Iterables.transform( Iterables.filter( ProxyServer.getInstance().getServers().values(), new Predicate<ServerInfo>()
+        return ( args.length > 1 ) ? Collections.EMPTY_LIST : Iterables.transform( Iterables.filter( ProxyServer.getInstance().getServersCopy().values(), new Predicate<ServerInfo>() // Waterfall: use #getServersCopy()
         {
             private final String lower = ( args.length == 0 ) ? "" : args[0].toLowerCase( Locale.ROOT );
 
diff --git a/module/pom.xml b/module/pom.xml
index cea355bd..b946e1bd 100644
--- a/module/pom.xml
+++ b/module/pom.xml
@@ -4,19 +4,19 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-parent</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-parent</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-module</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-module</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>pom</packaging>
 
-    <name>BungeeCord Modules</name>
-    <description>Parent project for all BungeeCord modules.</description>
+    <name>Waterfall Modules</name>
+    <description>Parent project for all Waterfall modules.</description>
 
     <modules>
         <module>cmd-alert</module>
@@ -29,15 +29,15 @@
     </modules>
 
     <properties>
-        <module.author>SpigotMC</module.author>
+        <module.author>WaterfallMC</module.author>
         <maven.deploy.skip>true</maven.deploy.skip>
         <maven.javadoc.skip>true</maven.javadoc.skip>
     </properties>
 
     <dependencies>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-api</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-api</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
diff --git a/module/reconnect-yaml/pom.xml b/module/reconnect-yaml/pom.xml
index f1fb430a..66e8e0b4 100644
--- a/module/reconnect-yaml/pom.xml
+++ b/module/reconnect-yaml/pom.xml
@@ -4,14 +4,14 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-module</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-module</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-module-reconnect-yaml</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-module-reconnect-yaml</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
diff --git a/native/pom.xml b/native/pom.xml
index bd3a8ab8..49347e1d 100644
--- a/native/pom.xml
+++ b/native/pom.xml
@@ -4,19 +4,19 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-parent</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-parent</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-native</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-native</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
-    <name>BungeeCord-Native</name>
-    <description>Optional native code to speed up and enhance BungeeCord functionality.</description>
+    <name>Waterfall-Native</name>
+    <description>Optional native code to speed up and enhance Waterfall functionality.</description>
 
     <dependencies>
         <dependency>
diff --git a/pom.xml b/pom.xml
index 7335e8b7..be640f9e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -3,18 +3,18 @@
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-parent</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-parent</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>pom</packaging>
 
-    <name>BungeeCord-Parent</name>
-    <description>Parent project for all BungeeCord modules.</description>
-    <url>https://github.com/SpigotMC/BungeeCord</url>
-    <inceptionYear>2012</inceptionYear>
+    <name>Waterfall-Parent</name>
+    <description>Parent project for all Waterfall modules.</description>
+    <url>https://github.com/WaterfallMC/Waterfall</url>
+    <inceptionYear>2015</inceptionYear>
     <organization>
-        <name>SpigotMC</name>
-        <url>https://github.com/SpigotMC</url>
+        <name>WaterfallMC</name>
+        <url>https://github.com/WaterfallMC</url>
     </organization>
     <licenses>
         <license>
@@ -26,7 +26,19 @@
 
     <developers>
         <developer>
-            <id>md_5</id>
+            <id>Tux</id>
+        </developer>
+        <developer>
+            <id>Techcable</id>
+        </developer>
+        <developer>
+            <id>kashike</id>
+        </developer>
+        <developer>
+            <id>jamierocks</id>
+        </developer>
+        <developer>
+            <id>fuzzybot</id>
         </developer>
     </developers>
 
@@ -36,38 +48,35 @@
         <module>chat</module>
         <module>config</module>
         <module>event</module>
-        <module>log</module>
+        <!--<module>log</module>-->
+        <module>log4j</module>
         <module>module</module>
         <module>protocol</module>
         <module>proxy</module>
         <module>query</module>
-        <module>slf4j</module>
+        <!--<module>slf4j</module>-->
         <module>native</module>
     </modules>
 
     <scm>
-        <connection>scm:git:git@github.com:SpigotMC/BungeeCord.git</connection>
-        <developerConnection>scm:git:git@github.com:SpigotMC/BungeeCord.git</developerConnection>
-        <url>git@github.com:SpigotMC/BungeeCord.git</url>
+        <connection>scm:git:git@github.com:com:WaterfallMC/Waterfall.git</connection>
+        <developerConnection>scm:git:git@github.com:WaterfallMC/Waterfall.git</developerConnection>
+        <url>git@github.com:WaterfallMC/Waterfall.git</url>
     </scm>
     <issueManagement>
         <system>GitHub</system>
-        <url>https://github.com/SpigotMC/BungeeCord/issues</url>
+        <url>https://github.com/PaperMC/Waterfall/issues</url>
     </issueManagement>
-    <ciManagement>
-        <system>jenkins</system>
-        <url>http://ci.md-5.net/job/BungeeCord</url>
-    </ciManagement>
 
     <distributionManagement>
-        <snapshotRepository>
-            <id>sonatype-nexus-snapshots</id>
-            <url>https://oss.sonatype.org/content/repositories/snapshots/</url>
-        </snapshotRepository>
         <repository>
-            <id>sonatype-nexus-staging</id>
-            <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
+            <id>papermc-releases</id>
+            <url>https://papermc.io/repo/repository/maven-releases/</url>
         </repository>
+        <snapshotRepository>
+            <id>papermc-snapshots</id>
+            <url>https://papermc.io/repo/repository/maven-snapshots/</url>
+        </snapshotRepository>
     </distributionManagement>
 
     <properties>
@@ -149,12 +158,21 @@
                     </execution>
                 </executions>
             </plugin>
+            <!-- Use latest version of the javadoc plugin, fixes some issues with the javadoc tool on recent JDK builds on macOS at least -->
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
                 <version>3.13.0</version>
             </plugin>
             <plugin>
+                <artifactId>maven-javadoc-plugin</artifactId>
+                <version>3.5.0</version>
+                <configuration>
+                    <doclint>none</doclint>
+                </configuration>
+            </plugin>
+            <!-- Alow manging of import orders to allow avoiding conflicts
+             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-checkstyle-plugin</artifactId>
                 <version>3.3.1</version>
@@ -179,6 +197,7 @@
                     </dependency>
                 </dependencies>
             </plugin>
+            -->
             <plugin>
                 <groupId>org.codehaus.mojo</groupId>
                 <artifactId>animal-sniffer-maven-plugin</artifactId>
@@ -291,6 +310,15 @@
                                 </goals>
                             </execution>
                         </executions>
+                        <!-- Waterfall start: TODO: Just convert this project to gradle.
+                        Maven is a constant source of headaches, especially when we have crud like
+                        lombok inflicted upon the project mangling the build setup. I don't have the will to
+                        figure out where the duplicate artifact is coming from, I cannot reproduce this locally,
+                        and so, we'll just do this for now.-->
+                        <configuration>
+                            <forceCreation>true</forceCreation>
+                        </configuration>
+                        <!-- Waterfall end -->
                     </plugin>
                     <plugin>
                         <groupId>org.projectlombok</groupId>
@@ -339,6 +367,7 @@
                                     <!-- lombok does not add @return or @param which causes warnings, so ignore -->
                                     <doclint>none</doclint>
                                     <sourcepath>${project.build.directory}/delombok</sourcepath>
+                                    <additionalJOption>--no-module-directories</additionalJOption> <!-- Waterfall -->
                                 </configuration>
                             </execution>
                         </executions>
diff --git a/protocol/pom.xml b/protocol/pom.xml
index d697cea8..b85d2755 100644
--- a/protocol/pom.xml
+++ b/protocol/pom.xml
@@ -4,19 +4,19 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-parent</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-parent</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-protocol</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-protocol</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
-    <name>BungeeCord-Protocol</name>
-    <description>Minimal implementation of the Minecraft protocol for use in BungeeCord</description>
+    <name>Waterfall-Protocol</name>
+    <description>Minimal implementation of the Minecraft protocol for use in Waterfall</description>
 
     <!-- We really shouldn't depend on external repositories -->
     <repositories>
@@ -35,8 +35,8 @@
             <scope>compile</scope>
         </dependency>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-chat</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-chat</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/AbstractPacketHandler.java b/protocol/src/main/java/net/md_5/bungee/protocol/AbstractPacketHandler.java
index 8d91211b..4dde7257 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/AbstractPacketHandler.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/AbstractPacketHandler.java
@@ -278,4 +278,18 @@ public abstract class AbstractPacketHandler
     public void handle(ServerLinks serverLinks) throws Exception
     {
     }
+
+    // Waterfall start
+    public void handle(net.md_5.bungee.protocol.packet.EntityEffect entityEffect) throws Exception
+    {
+    }
+
+    public void handle(net.md_5.bungee.protocol.packet.EntityRemoveEffect removeEffect) throws Exception
+    {
+    }
+
+    public void handle(net.md_5.bungee.protocol.packet.ClientChatAcknowledgement clientChatAcknowledgement)
+    {
+    }
+    // Waterfall end
 }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/BadPacketException.java b/protocol/src/main/java/net/md_5/bungee/protocol/BadPacketException.java
index 6c0ef4df..076ddd70 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/BadPacketException.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/BadPacketException.java
@@ -12,4 +12,24 @@ public class BadPacketException extends RuntimeException
     {
         super( message, cause );
     }
+
+    // Waterfall start
+    @Override
+    public Throwable initCause(Throwable cause)
+    {
+        if (DefinedPacket.PROCESS_TRACES) {
+            return super.initCause(cause);
+        }
+        return this;
+    }
+
+    @Override
+    public Throwable fillInStackTrace()
+    {
+        if (DefinedPacket.PROCESS_TRACES) {
+            return super.fillInStackTrace();
+        }
+        return this;
+    }
+    // Waterfall end
 }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/DefinedPacket.java b/protocol/src/main/java/net/md_5/bungee/protocol/DefinedPacket.java
index 6cd9e6a4..dafaba54 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/DefinedPacket.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/DefinedPacket.java
@@ -47,6 +47,9 @@ public abstract class DefinedPacket
         }
     }
 
+    public static final boolean PROCESS_TRACES = Boolean.getBoolean("waterfall.bad-packet-traces");
+    private static final OverflowPacketException OVERSIZED_VAR_INT_EXCEPTION = new OverflowPacketException( "VarInt too big" );
+    private static final BadPacketException NO_MORE_BYTES_EXCEPTION = new BadPacketException("No more bytes reading varint");
     public static void writeString(String s, ByteBuf buf)
     {
         writeString( s, buf, Short.MAX_VALUE );
@@ -79,6 +82,7 @@ public abstract class DefinedPacket
         int len = readVarInt( buf );
         if ( len > maxLen * 3 )
         {
+            if(!MinecraftDecoder.DEBUG) throw STRING_TOO_MANY_BYTES_EXCEPTION; // Waterfall start: Additional DoS mitigations
             throw new OverflowPacketException( "Cannot receive string longer than " + maxLen * 3 + " (got " + len + " bytes)" );
         }
 
@@ -87,6 +91,7 @@ public abstract class DefinedPacket
 
         if ( s.length() > maxLen )
         {
+            if(!MinecraftDecoder.DEBUG) throw STRING_TOO_LONG_EXCEPTION; // Waterfall start: Additional DoS mitigations
             throw new OverflowPacketException( "Cannot receive string longer than " + maxLen + " (got " + s.length() + " characters)" );
         }
 
@@ -242,13 +247,18 @@ public abstract class DefinedPacket
         byte in;
         while ( true )
         {
+            // Waterfall start
+            if (input.readableBytes() == 0) {
+                throw PROCESS_TRACES ? new BadPacketException("No more bytes reading varint") : NO_MORE_BYTES_EXCEPTION;
+            }
+            // Waterfall end
             in = input.readByte();
 
             out |= ( in & 0x7F ) << ( bytes++ * 7 );
 
             if ( bytes > maxBytes )
             {
-                throw new OverflowPacketException( "VarInt too big (max " + maxBytes + ")" );
+                throw PROCESS_TRACES ? new OverflowPacketException( "VarInt too big (max " + maxBytes + ")" ) : OVERSIZED_VAR_INT_EXCEPTION;
             }
 
             if ( ( in & 0x80 ) != 0x80 )
@@ -559,4 +569,21 @@ public abstract class DefinedPacket
 
     @Override
     public abstract String toString();
+
+    // Waterfall start: Additional DoS mitigations, courtesy of Velocity
+    private static final OverflowPacketException STRING_TOO_LONG_EXCEPTION
+            = new OverflowPacketException("A string was longer than allowed. For more "
+            + "information, launch Waterfall with -Dwaterfall.packet-decode-logging=true");
+    private static final OverflowPacketException STRING_TOO_MANY_BYTES_EXCEPTION
+            = new OverflowPacketException("A string had more data than allowed. For more "
+            + "information, launch Waterfall with -Dwaterfall.packet-decode-logging=true");
+
+    public int expectedMaxLength(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        return -1;
+    }
+
+    public int expectedMinLength(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        return 0;
+    }
+    // Waterfall end
 }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/FastDecoderException.java b/protocol/src/main/java/net/md_5/bungee/protocol/FastDecoderException.java
new file mode 100644
index 00000000..334d5054
--- /dev/null
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/FastDecoderException.java
@@ -0,0 +1,37 @@
+package net.md_5.bungee.protocol;
+
+import io.netty.handler.codec.DecoderException;
+
+public class FastDecoderException extends DecoderException {
+
+    private static final boolean PROCESS_TRACES = Boolean.getBoolean("waterfall.decoder-traces"); // Waterfall
+    public FastDecoderException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public FastDecoderException(String message) {
+        super(message);
+    }
+
+    @Override
+    public Throwable initCause(Throwable cause)
+    {
+        // Waterfall start
+        if (PROCESS_TRACES) {
+            return super.initCause(cause);
+        }
+        // Waterfall end
+        return this;
+    }
+
+    @Override
+    public Throwable fillInStackTrace()
+    {
+        // Waterfall start
+        if (PROCESS_TRACES) {
+            return super.fillInStackTrace();
+        }
+        // Waterfall end
+        return this;
+    }
+}
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java b/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java
index d79d5e5c..3a4a735c 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java
@@ -1,7 +1,9 @@
 package net.md_5.bungee.protocol;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.CorruptedFrameException;
 import io.netty.handler.codec.MessageToMessageDecoder;
 import java.util.List;
 import lombok.AllArgsConstructor;
@@ -18,6 +20,14 @@ public class MinecraftDecoder extends MessageToMessageDecoder<ByteBuf>
     private final boolean server;
     @Setter
     private int protocolVersion;
+    @Setter
+    private boolean supportsForge = false;
+
+    public MinecraftDecoder(Protocol protocol, boolean server, int protocolVersion) {
+        this.protocol = protocol;
+        this.server = server;
+        this.protocolVersion = protocolVersion;
+    }
 
     @Override
     protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception
@@ -32,17 +42,32 @@ public class MinecraftDecoder extends MessageToMessageDecoder<ByteBuf>
         Protocol.DirectionData prot = ( server ) ? protocol.TO_SERVER : protocol.TO_CLIENT;
         ByteBuf slice = in.copy(); // Can't slice this one due to EntityMap :(
 
+        Object packetTypeInfo = null;
         try
         {
+            // Waterfall start
+            if (in.readableBytes() == 0 && !server) {
+                return;
+            }
+            // Waterfall end
+
             int packetId = DefinedPacket.readVarInt( in );
+            packetTypeInfo = packetId;
 
-            DefinedPacket packet = prot.createPacket( packetId, protocolVersion );
+            DefinedPacket packet = prot.createPacket( packetId, protocolVersion, supportsForge );
             if ( packet != null )
             {
+                packetTypeInfo = packet.getClass();
+                doLengthSanityChecks(in, packet, prot.getDirection(), packetId); // Waterfall: Additional DoS mitigations
                 packet.read( in, protocol, prot.getDirection(), protocolVersion );
 
                 if ( in.isReadable() )
                 {
+                    // Waterfall start: Additional DoS mitigations
+                    if(!DEBUG) {
+                        throw PACKET_NOT_READ_TO_END;
+                    }
+                    // Waterfall end
                     throw new BadPacketException( "Packet " + protocol + ":" + prot.getDirection() + "/" + packetId + " (" + packet.getClass().getSimpleName() + ") larger than expected, extra bytes: " + in.readableBytes() );
                 }
             } else
@@ -52,6 +77,36 @@ public class MinecraftDecoder extends MessageToMessageDecoder<ByteBuf>
 
             out.add( new PacketWrapper( packet, slice, protocol ) );
             slice = null;
+        } catch (BadPacketException | IndexOutOfBoundsException e) {
+            // Waterfall start: Additional DoS mitigations
+            if(!DEBUG) {
+                throw e;
+            }
+            // Waterfall end
+            final String packetTypeStr;
+            if (packetTypeInfo instanceof Integer) {
+                packetTypeStr = "id " + Integer.toHexString((Integer) packetTypeInfo);
+            } else if (packetTypeInfo instanceof Class) {
+                packetTypeStr = "class " + ((Class) packetTypeInfo).getSimpleName();
+            } else {
+                packetTypeStr = "unknown";
+            }
+            throw new FastDecoderException("Error decoding packet " + packetTypeStr + " with contents:\n" + ByteBufUtil.prettyHexDump(slice), e); // Waterfall
+            // Waterfall start
+        } catch (Exception e) {
+            if (!DEBUG) {
+                throw e;
+            }
+            final String packetTypeStr;
+            if (packetTypeInfo instanceof Integer) {
+                packetTypeStr = "id " + Integer.toHexString((Integer) packetTypeInfo);
+            } else if (packetTypeInfo instanceof Class) {
+                packetTypeStr = "class " + ((Class) packetTypeInfo).getSimpleName();
+            } else {
+                packetTypeStr = "unknown";
+            }
+            throw new FastDecoderException("Error decoding packet " + packetTypeStr + " with contents:\n" + ByteBufUtil.prettyHexDump(slice), e); // Waterfall
+            // Waterfall end
         } finally
         {
             if ( slice != null )
@@ -60,4 +115,52 @@ public class MinecraftDecoder extends MessageToMessageDecoder<ByteBuf>
             }
         }
     }
+
+    // Waterfall start: Additional DoS mitigations, courtesy of Velocity
+    public static final boolean DEBUG = Boolean.getBoolean("waterfall.packet-decode-logging");
+
+    // Cached Exceptions:
+    private static final CorruptedFrameException PACKET_LENGTH_OVERSIZED =
+            new CorruptedFrameException("A packet could not be decoded because it was too large. For more "
+                    + "information, launch Waterfall with -Dwaterfall.packet-decode-logging=true");
+    private static final CorruptedFrameException PACKET_LENGTH_UNDERSIZED =
+            new CorruptedFrameException("A packet could not be decoded because it was smaller than allowed. For more "
+                    + "information, launch Waterfall with -Dwaterfall.packet-decode-logging=true");
+    private static final BadPacketException PACKET_NOT_READ_TO_END =
+            new BadPacketException("Couldn't read all bytes from a packet. For more "
+                    + "information, launch Waterfall with -Dwaterfall.packet-decode-logging=true");
+
+
+    private void doLengthSanityChecks(ByteBuf buf, DefinedPacket packet,
+                                      ProtocolConstants.Direction direction, int packetId) throws Exception {
+        int expectedMinLen = packet.expectedMinLength(buf, direction, protocolVersion);
+        int expectedMaxLen = packet.expectedMaxLength(buf, direction, protocolVersion);
+        if (expectedMaxLen != -1 && buf.readableBytes() > expectedMaxLen) {
+            throw handleOverflow(packet, expectedMaxLen, buf.readableBytes(), packetId);
+        }
+        if (buf.readableBytes() < expectedMinLen) {
+            throw handleUnderflow(packet, expectedMaxLen, buf.readableBytes(), packetId);
+        }
+    }
+
+    private Exception handleOverflow(DefinedPacket packet, int expected, int actual, int packetId) {
+        if (DEBUG) {
+            throw new CorruptedFrameException( "Packet " + packet.getClass() + " " + packetId
+                    + " Protocol " + protocolVersion + " was too big (expected "
+                    + expected + " bytes, got " + actual + " bytes)");
+        } else {
+            return PACKET_LENGTH_OVERSIZED;
+        }
+    }
+
+    private Exception handleUnderflow(DefinedPacket packet, int expected, int actual, int packetId) {
+        if (DEBUG) {
+            throw new CorruptedFrameException( "Packet " + packet.getClass() + " " + packetId
+                    + " Protocol " + protocolVersion + " was too small (expected "
+                    + expected + " bytes, got " + actual + " bytes)");
+        } else {
+            return PACKET_LENGTH_UNDERSIZED;
+        }
+    }
+    // Waterfall end
 }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/OverflowPacketException.java b/protocol/src/main/java/net/md_5/bungee/protocol/OverflowPacketException.java
index 237955ab..d0bd4d75 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/OverflowPacketException.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/OverflowPacketException.java
@@ -2,9 +2,28 @@ package net.md_5.bungee.protocol;
 
 public class OverflowPacketException extends RuntimeException
 {
-
     public OverflowPacketException(String message)
     {
         super( message );
     }
+
+    // Waterfall start
+    @Override
+    public Throwable initCause(Throwable cause)
+    {
+        if (DefinedPacket.PROCESS_TRACES) {
+            return super.initCause(cause);
+        }
+        return this;
+    }
+
+    @Override
+    public Throwable fillInStackTrace()
+    {
+        if (DefinedPacket.PROCESS_TRACES) {
+            return super.fillInStackTrace();
+        }
+        return this;
+    }
+    // Waterfall end
 }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/Protocol.java b/protocol/src/main/java/net/md_5/bungee/protocol/Protocol.java
index 8aa57ed4..fb239f75 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/Protocol.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/Protocol.java
@@ -2,6 +2,8 @@ package net.md_5.bungee.protocol;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterables;
+
+import gnu.trove.impl.Constants;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.TObjectIntMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
@@ -584,6 +586,13 @@ public enum Protocol
                     map( ProtocolConstants.MINECRAFT_1_20_5, 0x06 ),
                     map( ProtocolConstants.MINECRAFT_1_21_2, 0x07 )
             );
+            // Waterfall start
+            TO_SERVER.registerPacket(
+                    net.md_5.bungee.protocol.packet.ClientChatAcknowledgement.class,
+                    net.md_5.bungee.protocol.packet.ClientChatAcknowledgement::new,
+                    map (ProtocolConstants.MINECRAFT_1_19_3, 0x3)
+            );
+            // Waterfall end
             TO_SERVER.registerPacket(
                     TabCompleteRequest.class,
                     TabCompleteRequest::new,
@@ -917,14 +926,23 @@ public enum Protocol
             return protocol;
         }
 
+        public boolean hasPacket(int i, boolean supportsForge) {
+            return supportsForge || i >= 0 && i <= MAX_PACKET_ID;
+        }
+
         public final DefinedPacket createPacket(int id, int version)
+        {
+            return createPacket(id, version, true);
+        }
+
+        public final DefinedPacket createPacket(int id, int version, boolean supportsForge)
         {
             ProtocolData protocolData = getProtocolData( version );
             if ( protocolData == null )
             {
                 throw new BadPacketException( "Unsupported protocol version " + version );
             }
-            if ( id > MAX_PACKET_ID || id < 0 )
+            if ( !hasPacket(id, supportsForge) )
             {
                 throw new BadPacketException( "Packet with id " + id + " outside of range" );
             }
@@ -989,9 +1007,12 @@ public enum Protocol
             {
                 throw new BadPacketException( "Unsupported protocol version" );
             }
-            Preconditions.checkArgument( protocolData.packetMap.containsKey( packet ), "Cannot get ID for packet %s in phase %s with direction %s", packet, protocolPhase, direction );
+            // Waterfall start
+            final int packetId = protocolData.packetMap.get(packet);
+            Preconditions.checkArgument( packetId >= 0, "Cannot get ID for packet %s in phase %s with direction %s for protocol version %s", packet, protocolPhase, direction, version ); // Waterfall - add version
 
-            return protocolData.packetMap.get( packet );
+            return packetId;
+            // Waterfall end
         }
     }
 }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/ProtocolConstants.java b/protocol/src/main/java/net/md_5/bungee/protocol/ProtocolConstants.java
index a460d19e..7728ad8d 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/ProtocolConstants.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/ProtocolConstants.java
@@ -122,6 +122,16 @@ public class ProtocolConstants
         SUPPORTED_VERSION_IDS = supportedVersionIds.build();
     }
 
+    public static final boolean isBeforeOrEq(int before, int other)
+    {
+            return before <= other;
+    }
+
+    public static final boolean isAfterOrEq(int after, int other)
+    {
+            return after >= other;
+    }
+
     public enum Direction
     {
 
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/Varint21FrameDecoder.java b/protocol/src/main/java/net/md_5/bungee/protocol/Varint21FrameDecoder.java
index 277e70e8..3a802ca4 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/Varint21FrameDecoder.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/Varint21FrameDecoder.java
@@ -27,8 +27,7 @@ public class Varint21FrameDecoder extends ByteToMessageDecoder
 
         in.markReaderIndex();
 
-        final byte[] buf = new byte[ 3 ];
-        for ( int i = 0; i < buf.length; i++ )
+        for ( int i = 0; i < 3; i++ ) // Waterfall
         {
             if ( !in.isReadable() )
             {
@@ -36,11 +35,14 @@ public class Varint21FrameDecoder extends ByteToMessageDecoder
                 return;
             }
 
-            buf[i] = in.readByte();
-            if ( buf[i] >= 0 )
+            // Waterfall start
+            byte read = in.readByte();
+            if ( read >= 0 )
             {
-                int length = DefinedPacket.readVarInt( Unpooled.wrappedBuffer( buf ) );
-                if ( length == 0 )
+                in.resetReaderIndex();
+                int length = DefinedPacket.readVarInt( in );
+                // Waterfall end
+                if ( false && length == 0) // Waterfall - ignore
                 {
                     throw new CorruptedFrameException( "Empty Packet!" );
                 }
@@ -49,25 +51,11 @@ public class Varint21FrameDecoder extends ByteToMessageDecoder
                 {
                     in.resetReaderIndex();
                     return;
-                } else
-                {
-                    if ( in.hasMemoryAddress() )
-                    {
-                        out.add( in.readRetainedSlice( length ) );
-                    } else
-                    {
-                        if ( !DIRECT_WARNING )
-                        {
-                            DIRECT_WARNING = true;
-                            System.out.println( "Netty is not using direct IO buffers." );
-                        }
-
-                        // See https://github.com/SpigotMC/BungeeCord/issues/1717
-                        ByteBuf dst = ctx.alloc().directBuffer( length );
-                        in.readBytes( dst );
-                        out.add( dst );
-                    }
+                // Waterfall start
+                } else {
+                    out.add(in.readRetainedSlice(length));
                     return;
+                    // Waterfall end
                 }
             }
         }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/ClientChatAcknowledgement.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/ClientChatAcknowledgement.java
new file mode 100644
index 00000000..08ecf2a3
--- /dev/null
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/ClientChatAcknowledgement.java
@@ -0,0 +1,33 @@
+package net.md_5.bungee.protocol.packet;
+
+import io.netty.buffer.ByteBuf;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class ClientChatAcknowledgement extends DefinedPacket  {
+    private int offset;
+
+    @Override
+    public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        this.offset = DefinedPacket.readVarInt(buf);
+    }
+
+    @Override
+    public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        DefinedPacket.writeVarInt(this.offset, buf);
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/ClientCommand.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/ClientCommand.java
index 33c838f9..f259ee91 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/ClientCommand.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/ClientCommand.java
@@ -108,4 +108,9 @@ public class ClientCommand extends DefinedPacket
     {
         handler.handle( this );
     }
+
+    public boolean isSigned() {
+        if (salt == 0) return false;
+        return this.seenMessages != null && !this.seenMessages.getAcknowledged().isEmpty();
+    }
 }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/EncryptionResponse.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/EncryptionResponse.java
index 63e9d18d..545eec72 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/EncryptionResponse.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/EncryptionResponse.java
@@ -63,4 +63,17 @@ public class EncryptionResponse extends DefinedPacket
         private final long salt;
         private final byte[] signature;
     }
+
+    // Waterfall start: Additional DoS mitigations, courtesy of Velocity
+    public int expectedMaxLength(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        // It turns out these come out to the same length, whether we're talking >=1.8 or not.
+        // The length prefix always winds up being 2 bytes.
+        if (protocolVersion >= ProtocolConstants.MINECRAFT_1_19) return -1;
+        return 260;
+    }
+
+    public int expectedMinLength(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        return expectedMaxLength(buf, direction, protocolVersion);
+    }
+    // Waterfall end
 }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/EntityEffect.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/EntityEffect.java
new file mode 100644
index 00000000..d11a9ea9
--- /dev/null
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/EntityEffect.java
@@ -0,0 +1,45 @@
+package net.md_5.bungee.protocol.packet;
+
+import io.netty.buffer.ByteBuf;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class EntityEffect extends DefinedPacket {
+
+    private int entityId;
+    private int effectId;
+    private int amplifier;
+    private int duration;
+    private boolean hideParticles;
+
+    @Override
+    public void read(ByteBuf buf) {
+        this.entityId = readVarInt(buf);
+        this.effectId = buf.readUnsignedByte();
+        this.amplifier = buf.readUnsignedByte();
+        this.duration = readVarInt(buf);
+        this.hideParticles = buf.readBoolean();
+    }
+
+    @Override
+    public void write(ByteBuf buf) {
+        writeVarInt(this.entityId, buf);
+        buf.writeByte(this.effectId);
+        buf.writeByte(this.amplifier);
+        writeVarInt(this.duration, buf);
+        buf.writeBoolean(this.hideParticles);
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/EntityRemoveEffect.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/EntityRemoveEffect.java
new file mode 100644
index 00000000..7ed2dc3a
--- /dev/null
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/EntityRemoveEffect.java
@@ -0,0 +1,36 @@
+package net.md_5.bungee.protocol.packet;
+
+import io.netty.buffer.ByteBuf;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class EntityRemoveEffect extends DefinedPacket {
+
+    private int entityId;
+    private int effectId;
+
+    @Override
+    public void read(ByteBuf buf) {
+        this.entityId = readVarInt(buf);
+        this.effectId = buf.readUnsignedByte();
+    }
+
+    @Override
+    public void write(ByteBuf buf) {
+        writeVarInt(this.entityId, buf);
+        buf.writeByte(effectId);
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/LoginRequest.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/LoginRequest.java
index e62a3a03..9789215c 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/LoginRequest.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/LoginRequest.java
@@ -71,4 +71,13 @@ public class LoginRequest extends DefinedPacket
     {
         handler.handle( this );
     }
+
+    // Waterfall start: Additional DoS mitigations, courtesy of Velocity
+    public int expectedMaxLength(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        // Accommodate the rare (but likely malicious) use of UTF-8 usernames, since it is technically
+        // legal on the protocol level.
+        if (protocolVersion >= ProtocolConstants.MINECRAFT_1_19) return -1;
+        return 1 + (16 * 3);
+    }
+    // Waterfall end
 }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/PingPacket.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/PingPacket.java
index 5f24d425..3163a771 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/PingPacket.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/PingPacket.java
@@ -7,6 +7,7 @@ import lombok.EqualsAndHashCode;
 import lombok.NoArgsConstructor;
 import net.md_5.bungee.protocol.AbstractPacketHandler;
 import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.ProtocolConstants;
 
 @Data
 @NoArgsConstructor
@@ -34,4 +35,14 @@ public class PingPacket extends DefinedPacket
     {
         handler.handle( this );
     }
+
+    // Waterfall start: Additional DoS mitigations, courtesy of Velocity
+    public int expectedMaxLength(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        return 8;
+    }
+
+    public int expectedMinLength(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        return 8;
+    }
+    // Waterfall end
 }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/PluginMessage.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/PluginMessage.java
index 70b292f0..91f71c09 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/PluginMessage.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/PluginMessage.java
@@ -3,6 +3,7 @@ package net.md_5.bungee.protocol.packet;
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil; // Waterfall
 import java.io.ByteArrayInputStream;
 import java.io.DataInput;
 import java.io.DataInputStream;
@@ -47,10 +48,23 @@ public class PluginMessage extends DefinedPacket
             return "legacy:" + tag.toLowerCase( Locale.ROOT );
         }
     };
-    //
+
+    public PluginMessage(String tag, ByteBuf data, boolean allowExtendedPacket) {
+        this(tag, ByteBufUtil.getBytes(data), allowExtendedPacket);
+    }
+
     private String tag;
     private byte[] data;
 
+    public void setData(byte[] data) {
+        this.data = Preconditions.checkNotNull(data, "Null data");
+    }
+
+    public void setData(ByteBuf buf) {
+        Preconditions.checkNotNull(buf, "Null buffer");
+        setData(ByteBufUtil.getBytes(buf));
+    }
+
     /**
      * Allow this packet to be sent as an "extended" packet.
      */
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/StatusRequest.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/StatusRequest.java
index 738f0c92..ec33d337 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/StatusRequest.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/StatusRequest.java
@@ -6,6 +6,7 @@ import lombok.EqualsAndHashCode;
 import lombok.NoArgsConstructor;
 import net.md_5.bungee.protocol.AbstractPacketHandler;
 import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.ProtocolConstants;
 
 @Data
 @NoArgsConstructor
@@ -28,4 +29,10 @@ public class StatusRequest extends DefinedPacket
     {
         handler.handle( this );
     }
+
+    // Waterfall start: Additional DoS mitigations, courtesy of Velocity
+    public int expectedMaxLength(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        return 0;
+    }
+    // Waterfall end
 }
diff --git a/proxy/pom.xml b/proxy/pom.xml
index 764ae27d..c3b1ff9f 100644
--- a/proxy/pom.xml
+++ b/proxy/pom.xml
@@ -4,18 +4,18 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-parent</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-parent</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-proxy</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-proxy</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
-    <name>BungeeCord-Proxy</name>
+    <name>Waterfall-Proxy</name>
     <description>Proxy component of the Elastic Portal Suite</description>
 
     <properties>
@@ -34,6 +34,18 @@
             <artifactId>netty-codec-http</artifactId>
             <scope>compile</scope>
         </dependency>
+        <!-- Waterfall Start - add Netty DNS resolver -->
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-resolver-dns</artifactId>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-resolver-dns-native-macos</artifactId>
+            <classifier>osx-x86_64</classifier>
+        </dependency>
+        <!-- Waterfall End -->
         <dependency>
             <groupId>io.netty</groupId>
             <artifactId>netty-handler</artifactId>
@@ -64,41 +76,42 @@
             <classifier>linux-aarch_64</classifier>
         </dependency>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-api</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-api</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-log</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-log4j</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-native</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-native</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-protocol</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-protocol</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-query</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-query</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
+        <!-- // Waterfall - We already bundle an slf4j impl
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-slf4j</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-slf4j</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
-        </dependency>
+        </dependency> // Waterfall - We already bundle an slf4j impl -->
         <dependency>
             <groupId>net.sf.jopt-simple</groupId>
             <artifactId>jopt-simple</artifactId>
@@ -130,5 +143,56 @@
             <version>1.9.18</version>
             <scope>runtime</scope>
         </dependency>
+        <!-- Waterfall start - Console improvements - bring back slf4j-->
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-jdk14</artifactId>
+            <version>1.7.36</version>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>net.minecrell</groupId>
+            <artifactId>terminalconsoleappender</artifactId>
+            <version>1.3.0</version>
+            <exclusions>
+                <exclusion>
+                    <groupId>org.apache.logging.log4j</groupId>
+                    <artifactId>log4j-core</artifactId>
+                </exclusion>
+                <exclusion>
+                    <groupId>org.jline</groupId>
+                    <artifactId>jline-terminal</artifactId>
+                </exclusion>
+            </exclusions>
+        </dependency>
+        <dependency>
+            <groupId>org.jline</groupId>
+            <artifactId>jline-terminal-jansi</artifactId>
+            <version>3.21.0</version>
+            <scope>runtime</scope>
+        </dependency>
+        <!-- Waterfall end -->
     </dependencies>
+
+    <!-- Waterfall start - copy license files into jar -->
+    <build>
+        <resources>
+            <resource>
+                <directory>src/main/resources</directory>
+            </resource>
+            <resource>
+                <directory>../</directory>
+                <includes>
+                    <include>LICENSE</include>
+                </includes>
+            </resource>
+            <resource>
+                <directory>../../</directory>
+                <includes>
+                    <include>LICENSE.txt</include>
+                </includes>
+            </resource>
+        </resources>
+    </build>
+    <!-- Waterfall end -->
 </project>
diff --git a/proxy/src/main/java/io/github/waterfallmc/waterfall/conf/WaterfallConfiguration.java b/proxy/src/main/java/io/github/waterfallmc/waterfall/conf/WaterfallConfiguration.java
new file mode 100644
index 00000000..da0efa36
--- /dev/null
+++ b/proxy/src/main/java/io/github/waterfallmc/waterfall/conf/WaterfallConfiguration.java
@@ -0,0 +1,126 @@
+package io.github.waterfallmc.waterfall.conf;
+
+import com.google.common.base.Joiner;
+import net.md_5.bungee.conf.Configuration;
+import net.md_5.bungee.conf.YamlConfig;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+import java.io.File;
+
+public class WaterfallConfiguration extends Configuration {
+
+    /**
+     * Whether we log InitialHandler connections
+     * <p>
+     * Default is true
+     */
+    private boolean logInitialHandlerConnections = true;
+
+    /**
+     * The supported versions displayed to the client
+     * <p>Default is a comma separated list of supported versions. For example 1.8.x, 1.9.x, 1.10.x</p>
+     */
+    private String gameVersion;
+
+    /**
+     * Whether we use Netty's async DNS resolver for the HttpClient.
+     * <p>Default is true (use Netty's async DNS resolver)</p>
+     */
+    private boolean useNettyDnsResolver = true;
+
+    /*
+     * Throttling options
+     * Helps prevent players from overloading the servers behind us
+     */
+
+    /**
+     * How often players are allowed to send tab throttle.
+     * Value in milliseconds.
+     * <p/>
+     * Default is one packet per second.
+     */
+    private int tabThrottle = 1000;
+    private boolean disableModernTabLimiter = true;
+
+    private boolean disableEntityMetadataRewrite = false;
+    private boolean disableTabListRewrite = true;
+
+    /*
+     * Plugin Message limiting options
+     * Allows for more control over server-client communication
+     */
+
+    /**
+     * How many channels there can be between server and player,
+     * typically used by mods or some plugins.
+     */
+    private int pluginChannelLimit = 128;
+
+    /**
+     * How long the maximum channel name can be,
+     * only reason to change it would be broken mods.
+     */
+    private int pluginChannelNameLimit = 128;
+
+    @Override
+    public void load() {
+        super.load();
+        YamlConfig config = new YamlConfig(new File("waterfall.yml"));
+        config.load(false); // Load, but no permissions
+        logInitialHandlerConnections = config.getBoolean( "log_initial_handler_connections", logInitialHandlerConnections );
+        gameVersion = config.getString("game_version", "").isEmpty() ? Joiner.on(", ").join(ProtocolConstants.SUPPORTED_VERSIONS) : config.getString("game_version", "");
+        useNettyDnsResolver = config.getBoolean("use_netty_dns_resolver", useNettyDnsResolver);
+        // Throttling options
+        tabThrottle = config.getInt("throttling.tab_complete", tabThrottle);
+        disableModernTabLimiter = config.getBoolean("disable_modern_tab_limiter", disableModernTabLimiter);
+        disableEntityMetadataRewrite = config.getBoolean("disable_entity_metadata_rewrite", disableEntityMetadataRewrite);
+        disableTabListRewrite = config.getBoolean("disable_tab_list_rewrite", disableTabListRewrite);
+        pluginChannelLimit = config.getInt("registered_plugin_channels_limit", pluginChannelLimit);
+        pluginChannelNameLimit = config.getInt("plugin_channel_name_limit", pluginChannelNameLimit);
+    }
+
+    @Override
+    public boolean isLogInitialHandlerConnections() {
+        return logInitialHandlerConnections;
+    }
+
+    @Override
+    public String getGameVersion() {
+        return gameVersion;
+    }
+
+    @Override
+    public boolean isUseNettyDnsResolver() {
+        return useNettyDnsResolver;
+    }
+
+    @Override
+    public int getTabThrottle() {
+        return tabThrottle;
+    }
+
+    @Override
+    public boolean isDisableModernTabLimiter() {
+        return disableModernTabLimiter;
+    }
+
+    @Override
+    public boolean isDisableEntityMetadataRewrite() {
+        return disableEntityMetadataRewrite;
+    }
+
+    @Override
+    public boolean isDisableTabListRewrite() {
+        return disableTabListRewrite;
+    }
+
+    @Override
+    public int getPluginChannelLimit() {
+        return pluginChannelLimit;
+    }
+
+    @Override
+    public int getPluginChannelNameLimit() {
+        return pluginChannelNameLimit;
+    }
+}
diff --git a/proxy/src/main/java/io/github/waterfallmc/waterfall/console/ConsoleCommandCompleter.java b/proxy/src/main/java/io/github/waterfallmc/waterfall/console/ConsoleCommandCompleter.java
new file mode 100644
index 00000000..bfcb6e9f
--- /dev/null
+++ b/proxy/src/main/java/io/github/waterfallmc/waterfall/console/ConsoleCommandCompleter.java
@@ -0,0 +1,31 @@
+package io.github.waterfallmc.waterfall.console;
+
+import net.md_5.bungee.api.ProxyServer;
+import org.jline.reader.Candidate;
+import org.jline.reader.Completer;
+import org.jline.reader.LineReader;
+import org.jline.reader.ParsedLine;
+
+import java.util.List;
+
+final class ConsoleCommandCompleter implements Completer {
+
+    private final ProxyServer proxy;
+
+    ConsoleCommandCompleter(ProxyServer proxy) {
+        this.proxy = proxy;
+    }
+
+    @Override
+    public void complete(LineReader reader, ParsedLine line, List<Candidate> candidates) {
+        List<String> suggestions = this.proxy.getPluginManager().tabCompleteCommand(this.proxy.getConsole(), line.line());
+        if (suggestions.isEmpty()) {
+            return;
+        }
+
+        for (String suggestion : suggestions) {
+            candidates.add(new Candidate(suggestion));
+        }
+    }
+
+}
diff --git a/proxy/src/main/java/io/github/waterfallmc/waterfall/console/HexFormattingConverter.java b/proxy/src/main/java/io/github/waterfallmc/waterfall/console/HexFormattingConverter.java
new file mode 100644
index 00000000..5d1a6126
--- /dev/null
+++ b/proxy/src/main/java/io/github/waterfallmc/waterfall/console/HexFormattingConverter.java
@@ -0,0 +1,178 @@
+package io.github.waterfallmc.waterfall.console;
+
+import net.minecrell.terminalconsole.TerminalConsoleAppender;
+import org.apache.logging.log4j.core.LogEvent;
+import org.apache.logging.log4j.core.config.Configuration;
+import org.apache.logging.log4j.core.config.plugins.Plugin;
+import org.apache.logging.log4j.core.layout.PatternLayout;
+import org.apache.logging.log4j.core.pattern.*;
+import org.apache.logging.log4j.util.PerformanceSensitive;
+import org.apache.logging.log4j.util.PropertiesUtil;
+
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import static net.minecrell.terminalconsole.MinecraftFormattingConverter.KEEP_FORMATTING_PROPERTY;
+
+/**
+ * Modified version of <a href="https://github.com/Minecrell/TerminalConsoleAppender/blob/master/src/main/java/net/minecrell/terminalconsole/MinecraftFormattingConverter.java">
+ *     TerminalConsoleAppender's MinecraftFormattingConverter</a> to support hex color codes using the md_5 &x&r&r&g&g&b&b format.
+ */
+@Plugin(name = "paperMinecraftFormatting", category = PatternConverter.CATEGORY)
+@ConverterKeys({ "paperMinecraftFormatting" })
+@PerformanceSensitive("allocation")
+public final class HexFormattingConverter extends LogEventPatternConverter {
+
+  private static final boolean KEEP_FORMATTING = PropertiesUtil.getProperties().getBooleanProperty(KEEP_FORMATTING_PROPERTY);
+
+  private static final String ANSI_RESET = "\u001B[m";
+
+  private static final char COLOR_CHAR = '';
+  private static final String LOOKUP = "0123456789abcdefklmnor";
+
+  private static final String RGB_ANSI = "\u001B[38;2;%d;%d;%dm";
+  private static final Pattern NAMED_PATTERN = Pattern.compile(COLOR_CHAR + "[0-9a-fk-orA-FK-OR]");
+  private static final Pattern RGB_PATTERN = Pattern.compile(COLOR_CHAR + "x(" + COLOR_CHAR + "[0-9a-fA-F]){6}");
+
+  private static final String[] ansiCodes = new String[] {
+      "\u001B[0;30m",    // Black 0
+      "\u001B[0;34m",    // Dark Blue 1
+      "\u001B[0;32m",    // Dark Green 2
+      "\u001B[0;36m",    // Dark Aqua 3
+      "\u001B[0;31m",    // Dark Red 4
+      "\u001B[0;35m",    // Dark Purple 5
+      "\u001B[0;33m",    // Gold 6
+      "\u001B[0;37m",    // Gray 7
+      "\u001B[0;30;1m",  // Dark Gray 8
+      "\u001B[0;34;1m",  // Blue 9
+      "\u001B[0;32;1m",  // Green a
+      "\u001B[0;36;1m",  // Aqua b
+      "\u001B[0;31;1m",  // Red c
+      "\u001B[0;35;1m",  // Light Purple d
+      "\u001B[0;33;1m",  // Yellow e
+      "\u001B[0;37;1m",  // White f
+      "\u001B[5m",       // Obfuscated k
+      "\u001B[21m",      // Bold l
+      "\u001B[9m",       // Strikethrough m
+      "\u001B[4m",       // Underline n
+      "\u001B[3m",       // Italic o
+      ANSI_RESET,        // Reset r
+  };
+
+  private final boolean ansi;
+  private final List<PatternFormatter> formatters;
+
+  /**
+   * Construct the converter.
+   *
+   * @param formatters The pattern formatters to generate the text to manipulate
+   * @param strip      If true, the converter will strip all formatting codes
+   */
+  protected HexFormattingConverter(List<PatternFormatter> formatters, boolean strip) {
+    super("paperMinecraftFormatting", null);
+    this.formatters = formatters;
+    this.ansi = !strip;
+  }
+
+  @Override
+  public void format(LogEvent event, StringBuilder toAppendTo) {
+    int start = toAppendTo.length();
+    //noinspection ForLoopReplaceableByForEach
+    for (int i = 0, size = formatters.size(); i < size; i++) {
+      formatters.get(i).format(event, toAppendTo);
+    }
+
+    if (KEEP_FORMATTING || toAppendTo.length() == start) {
+      // Skip replacement if disabled or if the content is empty
+      return;
+    }
+
+    boolean useAnsi = ansi && TerminalConsoleAppender.isAnsiSupported();
+    String content = useAnsi ? convertRGBColors(toAppendTo.substring(start)) : stripRGBColors(toAppendTo.substring(start));
+    format(content, toAppendTo, start, useAnsi);
+  }
+
+  private static String convertRGBColors(String input) {
+    Matcher matcher = RGB_PATTERN.matcher(input);
+    StringBuffer buffer = new StringBuffer();
+    while (matcher.find()) {
+      String s = matcher.group().replace(String.valueOf(COLOR_CHAR), "").replace('x', '#');
+      int hex = Integer.decode(s);
+      int red = (hex >> 16) & 0xFF;
+      int green = (hex >> 8) & 0xFF;
+      int blue = hex & 0xFF;
+      String replacement = String.format(RGB_ANSI, red, green, blue);
+      matcher.appendReplacement(buffer, replacement);
+    }
+    matcher.appendTail(buffer);
+    return buffer.toString();
+  }
+
+  private static String stripRGBColors(String input) {
+    Matcher matcher = RGB_PATTERN.matcher(input);
+    StringBuffer buffer = new StringBuffer();
+    while (matcher.find()) {
+      matcher.appendReplacement(buffer, "");
+    }
+    matcher.appendTail(buffer);
+    return buffer.toString();
+  }
+
+  static void format(String content, StringBuilder result, int start, boolean ansi) {
+    int next = content.indexOf(COLOR_CHAR);
+    int last = content.length() - 1;
+    if (next == -1 || next == last) {
+      result.setLength(start);
+      result.append(content);
+      if (ansi) {
+        result.append(ANSI_RESET);
+      }
+      return;
+    }
+
+    Matcher matcher = NAMED_PATTERN.matcher(content);
+    StringBuffer buffer = new StringBuffer();
+    while (matcher.find()) {
+      int format = LOOKUP.indexOf(Character.toLowerCase(matcher.group().charAt(1)));
+      if (format != -1) {
+        matcher.appendReplacement(buffer, ansi ? ansiCodes[format] : "");
+      }
+    }
+    matcher.appendTail(buffer);
+
+    result.setLength(start);
+    result.append(buffer.toString());
+    if (ansi) {
+      result.append(ANSI_RESET);
+    }
+  }
+
+  /**
+   * Gets a new instance of the {@link HexFormattingConverter} with the
+   * specified options.
+   *
+   * @param config  The current configuration
+   * @param options The pattern options
+   * @return The new instance
+   *
+   * @see HexFormattingConverter
+   */
+  public static HexFormattingConverter newInstance(Configuration config, String[] options) {
+    if (options.length < 1 || options.length > 2) {
+      LOGGER.error("Incorrect number of options on paperMinecraftFormatting. Expected at least 1, max 2 received " + options.length);
+      return null;
+    }
+    if (options[0] == null) {
+      LOGGER.error("No pattern supplied on paperMinecraftFormatting");
+      return null;
+    }
+
+    PatternParser parser = PatternLayout.createPatternParser(config);
+    List<PatternFormatter> formatters = parser.parse(options[0]);
+    boolean strip = options.length > 1 && "strip".equals(options[1]);
+    return new HexFormattingConverter(formatters, strip);
+  }
+
+}
+
diff --git a/proxy/src/main/java/io/github/waterfallmc/waterfall/console/WaterfallConsole.java b/proxy/src/main/java/io/github/waterfallmc/waterfall/console/WaterfallConsole.java
new file mode 100644
index 00000000..6cec0b5a
--- /dev/null
+++ b/proxy/src/main/java/io/github/waterfallmc/waterfall/console/WaterfallConsole.java
@@ -0,0 +1,40 @@
+package io.github.waterfallmc.waterfall.console;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.chat.ComponentBuilder;
+import net.minecrell.terminalconsole.SimpleTerminalConsole;
+import org.jline.reader.LineReader;
+import org.jline.reader.LineReaderBuilder;
+
+public final class WaterfallConsole extends SimpleTerminalConsole {
+
+    @Override
+    protected LineReader buildReader(LineReaderBuilder builder) {
+        ProxyServer proxy = ProxyServer.getInstance();
+        return super.buildReader(builder
+                .appName(proxy.getName())
+                .completer(new ConsoleCommandCompleter(proxy))
+        );
+    }
+
+    @Override
+    protected boolean isRunning() {
+        return BungeeCord.getInstance().isRunning;
+    }
+
+    @Override
+    protected void runCommand(String command) {
+        ProxyServer proxy = ProxyServer.getInstance();
+        if (!proxy.getPluginManager().dispatchCommand(proxy.getConsole(), command)) {
+            proxy.getConsole().sendMessage(new ComponentBuilder("Command not found").color(ChatColor.RED).create());
+        }
+    }
+
+    @Override
+    protected void shutdown() {
+        ProxyServer.getInstance().stop();
+    }
+
+}
diff --git a/proxy/src/main/java/net/md_5/bungee/BungeeCord.java b/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
index e7f3f09a..9b93d2c3 100644
--- a/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
+++ b/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
@@ -9,6 +9,9 @@ import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import io.github.waterfallmc.waterfall.conf.WaterfallConfiguration;
+import io.github.waterfallmc.waterfall.event.ProxyExceptionEvent;
+import io.github.waterfallmc.waterfall.exception.ProxyPluginEnableDisableException;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
@@ -47,7 +50,6 @@ import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.logging.Handler;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import jline.console.ConsoleReader;
 import lombok.Getter;
 import lombok.Setter;
 import lombok.Synchronized;
@@ -82,15 +84,11 @@ import net.md_5.bungee.command.CommandEnd;
 import net.md_5.bungee.command.CommandIP;
 import net.md_5.bungee.command.CommandPerms;
 import net.md_5.bungee.command.CommandReload;
-import net.md_5.bungee.command.ConsoleCommandCompleter;
 import net.md_5.bungee.command.ConsoleCommandSender;
 import net.md_5.bungee.compress.CompressFactory;
 import net.md_5.bungee.conf.Configuration;
 import net.md_5.bungee.conf.YamlConfig;
 import net.md_5.bungee.forge.ForgeConstants;
-import net.md_5.bungee.log.BungeeLogger;
-import net.md_5.bungee.log.LoggingForwardHandler;
-import net.md_5.bungee.log.LoggingOutputStream;
 import net.md_5.bungee.module.ModuleManager;
 import net.md_5.bungee.netty.PipelineUtils;
 import net.md_5.bungee.protocol.DefinedPacket;
@@ -99,8 +97,6 @@ import net.md_5.bungee.protocol.packet.PluginMessage;
 import net.md_5.bungee.query.RemoteQuery;
 import net.md_5.bungee.scheduler.BungeeScheduler;
 import net.md_5.bungee.util.CaseInsensitiveMap;
-import org.fusesource.jansi.AnsiConsole;
-import org.slf4j.impl.JDK14LoggerFactory;
 
 /**
  * Main BungeeCord proxy class.
@@ -116,17 +112,17 @@ public class BungeeCord extends ProxyServer
      * Configuration.
      */
     @Getter
-    public final Configuration config = new Configuration();
+    public final Configuration config = new WaterfallConfiguration();
     /**
      * Localization formats.
      */
     private Map<String, Format> messageFormats;
-    public EventLoopGroup eventLoops;
+    public EventLoopGroup bossEventLoopGroup, workerEventLoopGroup;
     /**
      * locations.yml save thread.
      */
     private final Timer saveThread = new Timer( "Reconnect Saver" );
-    private final Timer metricsThread = new Timer( "Metrics Thread" );
+    // private final Timer metricsThread = new Timer( "Metrics Thread" ); // Waterfall: Disable Metrics
     /**
      * Server socket listener.
      */
@@ -160,8 +156,12 @@ public class BungeeCord extends ProxyServer
     private final File pluginsFolder = new File( "plugins" );
     @Getter
     private final BungeeScheduler scheduler = new BungeeScheduler();
+    // Waterfall start - Remove ConsoleReader for JLine 3 update
+    /*
     @Getter
     private final ConsoleReader consoleReader;
+    */
+    // Waterfall end
     @Getter
     private final Logger logger;
     public final Gson gson = new GsonBuilder()
@@ -192,7 +192,7 @@ public class BungeeCord extends ProxyServer
     public BungeeCord() throws IOException
     {
         // Java uses ! to indicate a resource inside of a jar/zip/other container. Running Bungee from within a directory that has a ! will cause this to muck up.
-        Preconditions.checkState( new File( "." ).getAbsolutePath().indexOf( '!' ) == -1, "Cannot use BungeeCord in directory with ! in path." );
+        Preconditions.checkState( new File( "." ).getAbsolutePath().indexOf( '!' ) == -1, "Cannot use Waterfall in directory with ! in path." );
 
         reloadMessages();
 
@@ -206,6 +206,8 @@ public class BungeeCord extends ProxyServer
         // BungeeCord. This version is only used when extracting the libraries to their temp folder.
         System.setProperty( "library.jansi.version", "BungeeCord" );
 
+        // Waterfall start - Use TerminalConsoleAppender and Log4J
+        /*
         AnsiConsole.systemInstall();
         consoleReader = new ConsoleReader();
         consoleReader.setExpandEvents( false );
@@ -230,6 +232,9 @@ public class BungeeCord extends ProxyServer
         // since it applies a nice looking format and also writes to the logfile.
         System.setErr( new PrintStream( new LoggingOutputStream( logger, Level.SEVERE ), true ) );
         System.setOut( new PrintStream( new LoggingOutputStream( logger, Level.INFO ), true ) );
+        */
+        logger = io.github.waterfallmc.waterfall.log4j.WaterfallLogger.create();
+        // Waterfall end
 
         pluginManager = new PluginManager( this );
         getPluginManager().registerCommand( null, new CommandReload() );
@@ -272,7 +277,8 @@ public class BungeeCord extends ProxyServer
             ResourceLeakDetector.setLevel( ResourceLeakDetector.Level.DISABLED ); // Eats performance
         }
 
-        eventLoops = PipelineUtils.newEventLoopGroup( 0, new ThreadFactoryBuilder().setNameFormat( "Netty IO Thread #%1$d" ).build() );
+        bossEventLoopGroup = PipelineUtils.newEventLoopGroup( 0, new ThreadFactoryBuilder().setNameFormat( "Netty Boss IO Thread #%1$d" ).build() );
+        workerEventLoopGroup = PipelineUtils.newEventLoopGroup( 0, new ThreadFactoryBuilder().setNameFormat( "Netty Worker IO Thread #%1$d" ).build() );
 
         File moduleDirectory = new File( "modules" );
         moduleManager.load( this, moduleDirectory );
@@ -289,8 +295,6 @@ public class BungeeCord extends ProxyServer
             registerChannel( ForgeConstants.FML_TAG );
             registerChannel( ForgeConstants.FML_HANDSHAKE_TAG );
             registerChannel( ForgeConstants.FORGE_REGISTER );
-
-            getLogger().warning( "MinecraftForge support is currently unmaintained and may have unresolved issues. Please use at your own risk." );
         }
 
         isRunning = true;
@@ -314,7 +318,7 @@ public class BungeeCord extends ProxyServer
                 }
             }
         }, 0, TimeUnit.MINUTES.toMillis( 5 ) );
-        metricsThread.scheduleAtFixedRate( new Metrics(), 0, TimeUnit.MINUTES.toMillis( Metrics.PING_INTERVAL ) );
+        //metricsThread.scheduleAtFixedRate( new Metrics(), 0, TimeUnit.MINUTES.toMillis( Metrics.PING_INTERVAL ) ); // Waterfall: Disable Metrics
 
         Runtime.getRuntime().addShutdownHook( new Thread()
         {
@@ -357,11 +361,11 @@ public class BungeeCord extends ProxyServer
                 }
             };
             new ServerBootstrap()
-                    .channel( PipelineUtils.getServerChannel( info.getSocketAddress() ) )
+                    .channelFactory( PipelineUtils.getServerChannelFactory( info.getSocketAddress() ) ) // Waterfall - netty reflection -> factory
                     .option( ChannelOption.SO_REUSEADDR, true ) // TODO: Move this elsewhere!
                     .childAttr( PipelineUtils.LISTENER, info )
                     .childHandler( PipelineUtils.SERVER_CHILD )
-                    .group( eventLoops )
+                    .group( bossEventLoopGroup, workerEventLoopGroup )
                     .localAddress( info.getSocketAddress() )
                     .bind().addListener( listener );
 
@@ -384,7 +388,7 @@ public class BungeeCord extends ProxyServer
                         }
                     }
                 };
-                new RemoteQuery( this, info ).start( PipelineUtils.getDatagramChannel(), new InetSocketAddress( info.getHost().getAddress(), info.getQueryPort() ), eventLoops, bindListener );
+                new RemoteQuery( this, info ).start( PipelineUtils.getDatagramChannel(), new InetSocketAddress( info.getHost().getAddress(), info.getQueryPort() ), workerEventLoopGroup, bindListener );
             }
         }
     }
@@ -472,7 +476,7 @@ public class BungeeCord extends ProxyServer
             reconnectHandler.close();
         }
         saveThread.cancel();
-        metricsThread.cancel();
+        //metricsThread.cancel(); // Waterfall: Disable Metrics
 
         getLogger().info( "Disabling plugins" );
         for ( Plugin plugin : Lists.reverse( new ArrayList<>( pluginManager.getPlugins() ) ) )
@@ -486,27 +490,30 @@ public class BungeeCord extends ProxyServer
                 }
             } catch ( Throwable t )
             {
-                getLogger().log( Level.SEVERE, "Exception disabling plugin " + plugin.getDescription().getName(), t );
+                // Waterfall start - throw exception event
+                String msg = "Exception disabling plugin " + plugin.getDescription().getName();
+                getLogger().log( Level.SEVERE, msg, t );
+                pluginManager.callEvent( new ProxyExceptionEvent( new ProxyPluginEnableDisableException( msg, t, plugin) ) );
+                // Waterfall end
             }
             getScheduler().cancel( plugin );
             plugin.getExecutorService().shutdownNow();
         }
 
         getLogger().info( "Closing IO threads" );
-        eventLoops.shutdownGracefully();
-        try
-        {
-            eventLoops.awaitTermination( Long.MAX_VALUE, TimeUnit.NANOSECONDS );
-        } catch ( InterruptedException ex )
-        {
+                bossEventLoopGroup.shutdownGracefully();
+                workerEventLoopGroup.shutdownGracefully();
+                while (true) {
+                    try {
+                        bossEventLoopGroup.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
+                        workerEventLoopGroup.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
+                        break;
+                    } catch (InterruptedException ignored) {}
         }
 
         getLogger().info( "Thank you and goodbye" );
         // Need to close loggers after last message!
-        for ( Handler handler : getLogger().getHandlers() )
-        {
-            handler.close();
-        }
+        org.apache.logging.log4j.LogManager.shutdown(); // Waterfall
 
         // Unlock the thread before optionally calling system exit, which might invoke this function again.
         // If that happens, the system will obtain the lock, and then see that isRunning == false and return without doing anything.
@@ -541,7 +548,7 @@ public class BungeeCord extends ProxyServer
     @Override
     public String getName()
     {
-        return "BungeeCord";
+        return "Waterfall";
     }
 
     @Override
@@ -663,10 +670,18 @@ public class BungeeCord extends ProxyServer
         return config.getServers();
     }
 
+    // Waterfall start
+    @Override
+    public Map<String, ServerInfo> getServersCopy()
+    {
+        return config.getServersCopy();
+    }
+    // Waterfall end
+
     @Override
     public ServerInfo getServerInfo(String name)
     {
-        return getServers().get( name );
+        return config.getServerInfo( name ); // Waterfall
     }
 
     @Override
@@ -709,7 +724,7 @@ public class BungeeCord extends ProxyServer
     @Override
     public String getGameVersion()
     {
-        return ProtocolConstants.SUPPORTED_VERSIONS.get( 0 ) + "-" + ProtocolConstants.SUPPORTED_VERSIONS.get( ProtocolConstants.SUPPORTED_VERSIONS.size() - 1 );
+        return getConfig().getGameVersion(); // Waterfall
     }
 
     @Override
diff --git a/proxy/src/main/java/net/md_5/bungee/BungeeCordLauncher.java b/proxy/src/main/java/net/md_5/bungee/BungeeCordLauncher.java
index 7281d6b2..72d6a15d 100644
--- a/proxy/src/main/java/net/md_5/bungee/BungeeCordLauncher.java
+++ b/proxy/src/main/java/net/md_5/bungee/BungeeCordLauncher.java
@@ -53,21 +53,25 @@ public class BungeeCordLauncher
             deadline.add( Calendar.WEEK_OF_YEAR, -8 );
             if ( buildDate.before( deadline.getTime() ) )
             {
-                System.err.println( "*** Warning, this build is outdated ***" );
-                System.err.println( "*** Please download a new build from http://ci.md-5.net/job/BungeeCord ***" );
-                System.err.println( "*** You will get NO support regarding this build ***" );
-                System.err.println( "*** Server will start in 10 seconds ***" );
-                Thread.sleep( TimeUnit.SECONDS.toMillis( 10 ) );
+                System.err.println( "*** Hey! This build is potentially outdated :( ***" );
+                System.err.println( "*** Please check for a new build from https://papermc.io/downloads ***" );
+                System.err.println( "*** Should this build be outdated, you will get NO support for it. ***" );
+                //System.err.println( "*** Server will start in 10 seconds ***" );
+                //Thread.sleep( TimeUnit.SECONDS.toMillis( 10 ) );
             }
         }
 
         BungeeCord bungee = new BungeeCord();
         ProxyServer.setInstance( bungee );
-        bungee.getLogger().info( "Enabled BungeeCord version " + bungee.getVersion() );
+        bungee.getLogger().info( "Enabled Waterfall version " + bungee.getVersion() );
+        bungee.getLogger().warning("Waterfall has reached end of life and is no longer maintained. We recommend you transition to Velocity (https://papermc.io/software/velocity). For more information, see the announcement (https://forums.papermc.io/threads/1088/)."); // Waterfall - eol message
         bungee.start();
 
         if ( !options.has( "noconsole" ) )
         {
+            // Waterfall start - Use TerminalConsoleAppender
+            new io.github.waterfallmc.waterfall.console.WaterfallConsole().start();
+            /*
             String line;
             while ( bungee.isRunning && ( line = bungee.getConsoleReader().readLine( ">" ) ) != null )
             {
@@ -76,6 +80,8 @@ public class BungeeCordLauncher
                     bungee.getConsole().sendMessage( new ComponentBuilder( "Command not found" ).color( ChatColor.RED ).create() );
                 }
             }
+            */
+            // Waterfall end
         }
     }
 }
diff --git a/proxy/src/main/java/net/md_5/bungee/BungeeServerInfo.java b/proxy/src/main/java/net/md_5/bungee/BungeeServerInfo.java
index 671cf96f..8f531f85 100644
--- a/proxy/src/main/java/net/md_5/bungee/BungeeServerInfo.java
+++ b/proxy/src/main/java/net/md_5/bungee/BungeeServerInfo.java
@@ -184,8 +184,8 @@ public class BungeeServerInfo implements ServerInfo
             }
         };
         new Bootstrap()
-                .channel( PipelineUtils.getChannel( socketAddress ) )
-                .group( BungeeCord.getInstance().eventLoops )
+                .channelFactory( PipelineUtils.getChannelFactory( socketAddress ) ) // Waterfall - netty reflection -> factory
+                .group( BungeeCord.getInstance().workerEventLoopGroup )
                 .handler( PipelineUtils.BASE_SERVERSIDE )
                 .option( ChannelOption.CONNECT_TIMEOUT_MILLIS, BungeeCord.getInstance().getConfig().getRemotePingTimeout() )
                 .remoteAddress( socketAddress )
diff --git a/proxy/src/main/java/net/md_5/bungee/Metrics.java b/proxy/src/main/java/net/md_5/bungee/Metrics.java
deleted file mode 100644
index eabf7573..00000000
--- a/proxy/src/main/java/net/md_5/bungee/Metrics.java
+++ /dev/null
@@ -1,134 +0,0 @@
-package net.md_5.bungee;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
-import java.io.UnsupportedEncodingException;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.URLEncoder;
-import java.util.TimerTask;
-import net.md_5.bungee.api.ProxyServer;
-
-public class Metrics extends TimerTask
-{
-
-    /**
-     * The current revision number
-     */
-    private static final int REVISION = 5;
-    /**
-     * The base url of the metrics domain
-     */
-    private static final String BASE_URL = "https://mcstats.spigotmc.org";
-    /**
-     * The url used to report a server's status
-     */
-    private static final String REPORT_URL = "/report/%s";
-    /**
-     * Interval of time to ping (in minutes)
-     */
-    static final int PING_INTERVAL = 10;
-    boolean firstPost = true;
-
-    @Override
-    public void run()
-    {
-        try
-        {
-            // We use the inverse of firstPost because if it is the first time we are posting,
-            // it is not a interval ping, so it evaluates to FALSE
-            // Each time thereafter it will evaluate to TRUE, i.e PING!
-            postPlugin( !firstPost );
-
-            // After the first post we set firstPost to false
-            // Each post thereafter will be a ping
-            firstPost = false;
-        } catch ( IOException ex )
-        {
-            // ProxyServer.getInstance().getLogger().info( "[Metrics] " + ex.getMessage() );
-        }
-    }
-
-    /**
-     * Generic method that posts a plugin to the metrics website.
-     *
-     * @param isPing first post or not
-     * @throws IOException any errors encountered
-     */
-    private void postPlugin(boolean isPing) throws IOException
-    {
-        // Construct the post data
-        final StringBuilder data = new StringBuilder();
-        data.append( encode( "guid" ) ).append( '=' ).append( encode( BungeeCord.getInstance().config.getUuid() ) );
-        encodeDataPair( data, "version", ProxyServer.getInstance().getVersion() );
-        encodeDataPair( data, "server", "0" );
-        encodeDataPair( data, "players", Integer.toString( ProxyServer.getInstance().getOnlineCount() ) );
-        encodeDataPair( data, "revision", String.valueOf( REVISION ) );
-
-        // If we're pinging, append it
-        if ( isPing )
-        {
-            encodeDataPair( data, "ping", "true" );
-        }
-
-        // Create the url
-        URL url = new URL( BASE_URL + String.format( REPORT_URL, encode( "BungeeCord" ) ) );
-
-        // Connect to the website
-        URLConnection connection;
-
-        connection = url.openConnection();
-
-        connection.setDoOutput( true );
-        final BufferedReader reader;
-        final String response;
-        try ( OutputStreamWriter writer = new OutputStreamWriter( connection.getOutputStream() ) )
-        {
-            writer.write( data.toString() );
-            writer.flush();
-            reader = new BufferedReader( new InputStreamReader( connection.getInputStream() ) );
-            response = reader.readLine();
-        }
-        reader.close();
-
-        if ( response == null || response.startsWith( "ERR" ) )
-        {
-            throw new IOException( response ); //Throw the exception
-        }
-    }
-
-    /**
-     * <p>
-     * Encode a key/value data pair to be used in a HTTP post request. This
-     * INCLUDES a & so the first key/value pair MUST be included manually,
-     * e.g:</p>
-     * <code>
-     * StringBuffer data = new StringBuffer();
-     * data.append(encode("guid")).append('=').append(encode(guid));
-     * encodeDataPair(data, "version", description.getVersion());
-     * </code>
-     *
-     * @param buffer the StringBuilder to append the data pair onto
-     * @param key the key value
-     * @param value the value
-     * @throws UnsupportedEncodingException if UTF-8 encoding not supported
-     */
-    private static void encodeDataPair(final StringBuilder buffer, final String key, final String value) throws UnsupportedEncodingException
-    {
-        buffer.append( '&' ).append( encode( key ) ).append( '=' ).append( encode( value ) );
-    }
-
-    /**
-     * Encode text as UTF-8
-     *
-     * @param text the text to encode
-     * @return the encoded text, as UTF-8
-     * @throws UnsupportedEncodingException if UTF-8 encoding not supported
-     */
-    private static String encode(final String text) throws UnsupportedEncodingException
-    {
-        return URLEncoder.encode( text, "UTF-8" );
-    }
-}
diff --git a/proxy/src/main/java/net/md_5/bungee/ServerConnector.java b/proxy/src/main/java/net/md_5/bungee/ServerConnector.java
index b58a01c6..cc5afa04 100644
--- a/proxy/src/main/java/net/md_5/bungee/ServerConnector.java
+++ b/proxy/src/main/java/net/md_5/bungee/ServerConnector.java
@@ -7,6 +7,7 @@ import io.netty.buffer.ByteBufAllocator;
 import java.net.InetSocketAddress;
 import java.nio.charset.StandardCharsets;
 import java.util.Locale;
+import java.util.Arrays; // Waterfall
 import java.util.Queue;
 import java.util.Set;
 import java.util.UUID;
@@ -115,15 +116,39 @@ public class ServerConnector extends PacketHandler
             String newHost = copiedHandshake.getHost() + "\00" + AddressUtil.sanitizeAddress( user.getAddress() ) + "\00" + user.getUUID();
 
             LoginResult profile = user.getPendingConnection().getLoginProfile();
+
+            // Handle properties.
+            net.md_5.bungee.protocol.Property[] properties = new net.md_5.bungee.protocol.Property[0];
+
             if ( profile != null && profile.getProperties() != null && profile.getProperties().length > 0 )
             {
-                newHost += "\00" + BungeeCord.getInstance().gson.toJson( profile.getProperties() );
+                properties = profile.getProperties();
+            }
+
+            if ( user.getForgeClientHandler().isFmlTokenInHandshake() )
+            {
+                // Get the current properties and copy them into a slightly bigger array.
+                net.md_5.bungee.protocol.Property[] newp = Arrays.copyOf( properties, properties.length + 2 );
+
+                // Add a new profile property that specifies that this user is a Forge user.
+                newp[newp.length - 2] = new net.md_5.bungee.protocol.Property( ForgeConstants.FML_LOGIN_PROFILE, "true", null );
+
+                // If we do not perform the replacement, then the IP Forwarding code in Spigot et. al. will try to split on this prematurely.
+                newp[newp.length - 1] = new net.md_5.bungee.protocol.Property( ForgeConstants.EXTRA_DATA, user.getExtraDataInHandshake().replaceAll( "\0", "\1"), "" );
+
+                // All done.
+                properties = newp;
+            }
+
+            // If we touched any properties, then append them
+            if (properties.length > 0) {
+                newHost += "\00" + BungeeCord.getInstance().gson.toJson(properties);
             }
+
             copiedHandshake.setHost( newHost );
         } else if ( !user.getExtraDataInHandshake().isEmpty() )
         {
-            // Only restore the extra data if IP forwarding is off.
-            // TODO: Add support for this data with IP forwarding.
+            // Restore the extra data
             copiedHandshake.setHost( copiedHandshake.getHost() + user.getExtraDataInHandshake() );
         }
 
@@ -218,6 +243,12 @@ public class ServerConnector extends PacketHandler
     public static void handleLogin(ProxyServer bungee, ChannelWrapper ch, UserConnection user, BungeeServerInfo target, ForgeServerHandler handshakeHandler, ServerConnection server, Login login) throws Exception
     {
         ServerConnectedEvent event = new ServerConnectedEvent( user, server );
+
+        if (server.isForgeServer() && user.isForgeUser()) {
+            ((net.md_5.bungee.protocol.MinecraftDecoder) server.getCh().getHandle().pipeline().get(net.md_5.bungee.netty.PipelineUtils.PACKET_DECODER)).setSupportsForge(true);
+            ((net.md_5.bungee.protocol.MinecraftDecoder) user.getCh().getHandle().pipeline().get(net.md_5.bungee.netty.PipelineUtils.PACKET_DECODER)).setSupportsForge(true);
+        }
+
         bungee.getPluginManager().callEvent( event );
 
         ch.write( BungeeCord.getInstance().registerChannels( user.getPendingConnection().getVersion() ) );
@@ -242,7 +273,8 @@ public class ServerConnector extends PacketHandler
             ch.write( new PluginMessage( user.getPendingConnection().getVersion() >= ProtocolConstants.MINECRAFT_1_13 ? "minecraft:register" : "REGISTER", Joiner.on( "\0" ).join( registeredChannels ).getBytes( StandardCharsets.UTF_8 ), false ) );
         }
 
-        if ( user.getSettings() != null )
+        // Something deeper is going wrong here, but, as it stands, this project is EOL, so, we'll just shove this through.
+        if (user.getSettings() != null && (!user.isDisableEntityMetadataRewrite() || user.getPendingConnection().getVersion() >= ProtocolConstants.MINECRAFT_1_20_2))
         {
             ch.write( user.getSettings() );
         }
@@ -286,7 +318,7 @@ public class ServerConnector extends PacketHandler
 
                 ByteBuf brand = ByteBufAllocator.DEFAULT.heapBuffer();
                 DefinedPacket.writeString( bungee.getName() + " (" + bungee.getVersion() + ")", brand );
-                user.unsafe().sendPacket( new PluginMessage( user.getPendingConnection().getVersion() >= ProtocolConstants.MINECRAFT_1_13 ? "minecraft:brand" : "MC|Brand", DefinedPacket.toArray( brand ), handshakeHandler != null && handshakeHandler.isServerForge() ) );
+                user.unsafe().sendPacket( new PluginMessage( user.getPendingConnection().getVersion() >= ProtocolConstants.MINECRAFT_1_13 ? "minecraft:brand" : "MC|Brand", brand, handshakeHandler != null && handshakeHandler.isServerForge() ) ); // Waterfall
                 brand.release();
             }
 
@@ -297,6 +329,7 @@ public class ServerConnector extends PacketHandler
             user.getTabListHandler().onServerChange();
 
             Scoreboard serverScoreboard = user.getServerSentScoreboard();
+            if ( !user.isDisableEntityMetadataRewrite() ) { // Waterfall
             for ( Objective objective : serverScoreboard.getObjectives() )
             {
                 user.unsafe().sendPacket( new ScoreboardObjective(
@@ -320,6 +353,7 @@ public class ServerConnector extends PacketHandler
             {
                 user.unsafe().sendPacket( new net.md_5.bungee.protocol.packet.Team( team.getName() ) );
             }
+            } // Waterfall
             serverScoreboard.clear();
 
             for ( UUID bossbar : user.getSentBossBars() )
@@ -338,13 +372,34 @@ public class ServerConnector extends PacketHandler
             }
 
             user.setDimensionChange( true );
-            if ( login.getDimension() == user.getDimension() )
+            if ( !user.isDisableEntityMetadataRewrite() && login.getDimension() == user.getDimension() ) // Waterfall - defer
             {
                 user.unsafe().sendPacket( new Respawn( (Integer) login.getDimension() >= 0 ? -1 : 0, login.getWorldName(), login.getSeed(), login.getDifficulty(), login.getGameMode(), login.getPreviousGameMode(), login.getLevelType(), login.isDebug(), login.isFlat(),
                         (byte) 0, login.getDeathLocation(), login.getPortalCooldown(), login.getSeaLevel() ) );
             }
 
             user.setServerEntityId( login.getEntityId() );
+
+            // Waterfall start
+            if ( user.isDisableEntityMetadataRewrite() ) {
+                // Ensure that we maintain consistency
+                user.setClientEntityId( login.getEntityId() );
+                // Only send if we are not in the same dimension
+                if ( login.getDimension() != user.getDimension() ) // Waterfall - defer
+                {
+                    user.unsafe().sendPacket( new Respawn( (Integer) user.getDimension() >= 0 ? -1 : 0, login.getWorldName(), login.getSeed(), login.getDifficulty(), login.getGameMode(), login.getPreviousGameMode(), login.getLevelType(), login.isDebug(), login.isFlat(), (byte) 0, login.getDeathLocation(), login.getPortalCooldown(), login.getSeaLevel() ) );
+                }
+                Login modLogin = new Login( login.getEntityId(), login.isHardcore(), login.getGameMode(), login.getPreviousGameMode(), login.getWorldNames(), login.getDimensions(), login.getDimension(), login.getWorldName(), login.getSeed(), login.getDifficulty(),
+                        (byte) user.getPendingConnection().getListener().getTabListSize(), login.getLevelType(), login.getViewDistance(), login.getSimulationDistance(), login.isReducedDebugInfo(), login.isNormalRespawn(), login.isLimitedCrafting(), login.isDebug(), login.isFlat(), login.getDeathLocation(),
+                        login.getPortalCooldown(), login.getSeaLevel(), login.isSecureProfile() );
+                user.unsafe().sendPacket(modLogin);
+                // Only send if we're in the same dimension
+                if ( login.getDimension() == user.getDimension() ) // Waterfall - defer
+                {
+                    user.unsafe().sendPacket( new Respawn( (Integer) login.getDimension() >= 0 ? -1 : 0, login.getWorldName(), login.getSeed(), login.getDifficulty(), login.getGameMode(), login.getPreviousGameMode(), login.getLevelType(), login.isDebug(), login.isFlat(), (byte) 0, login.getDeathLocation(), login.getPortalCooldown(), login.getSeaLevel() ) );
+                }
+            }
+            // Waterfall end
             user.unsafe().sendPacket( new Respawn( login.getDimension(), login.getWorldName(), login.getSeed(), login.getDifficulty(), login.getGameMode(), login.getPreviousGameMode(), login.getLevelType(), login.isDebug(), login.isFlat(),
                     (byte) 0, login.getDeathLocation(), login.getPortalCooldown(), login.getSeaLevel() ) );
             if ( user.getPendingConnection().getVersion() >= ProtocolConstants.MINECRAFT_1_14 )
@@ -419,7 +474,7 @@ public class ServerConnector extends PacketHandler
         ServerKickEvent event = new ServerKickEvent( user, target, new BaseComponent[]
         {
             kick.getMessage()
-        }, def, ServerKickEvent.State.CONNECTING );
+        }, def, ServerKickEvent.State.CONNECTING, ServerKickEvent.Cause.SERVER );  // Waterfall );
         if ( event.getKickReason().toLowerCase( Locale.ROOT ).contains( "outdated" ) && def != null )
         {
             // Pre cancel the event if we are going to try another server
@@ -502,6 +557,6 @@ public class ServerConnector extends PacketHandler
     @Override
     public String toString()
     {
-        return "[" + user.getName() + "] <-> ServerConnector [" + target.getName() + "]";
+        return "[" + user.getName() + "|" + user.getAddress() + "] <-> ServerConnector [" + target.getName() + "]";
     }
 }
diff --git a/proxy/src/main/java/net/md_5/bungee/UserConnection.java b/proxy/src/main/java/net/md_5/bungee/UserConnection.java
index 2359e864..d6561c60 100644
--- a/proxy/src/main/java/net/md_5/bungee/UserConnection.java
+++ b/proxy/src/main/java/net/md_5/bungee/UserConnection.java
@@ -1,7 +1,9 @@
 package net.md_5.bungee;
 
 import com.google.common.base.Preconditions;
+import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Multimap;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
@@ -129,6 +131,10 @@ public final class UserConnection implements ProxiedPlayer
     private final Scoreboard serverSentScoreboard = new Scoreboard();
     @Getter
     private final Collection<UUID> sentBossBars = new HashSet<>();
+    // Waterfall start
+    @Getter
+    private final Multimap<Integer, Integer> potions = HashMultimap.create();
+    // Waterfall end
     @Getter
     @Setter
     private String lastCommandTabbed;
@@ -173,9 +179,12 @@ public final class UserConnection implements ProxiedPlayer
 
         forgeClientHandler = new ForgeClientHandler( this );
 
+        // No-config FML handshake marker.
         // Set whether the connection has a 1.8 FML marker in the handshake.
-        forgeClientHandler.setFmlTokenInHandshake( this.getPendingConnection().getExtraDataInHandshake().contains( ForgeConstants.FML_HANDSHAKE_TOKEN ) );
-
+        if (this.getPendingConnection().getExtraDataInHandshake().contains( ForgeConstants.FML_HANDSHAKE_TOKEN ))
+        {
+            forgeClientHandler.setFmlTokenInHandshake( true );
+        }
         return BungeeCord.getInstance().addConnection( this );
     }
 
@@ -282,9 +291,24 @@ public final class UserConnection implements ProxiedPlayer
 
     public void connect(ServerInfo info, final Callback<Boolean> callback, final boolean retry, ServerConnectEvent.Reason reason)
     {
+        // Waterfall start
+        connect(info, callback, retry, reason, bungee.getConfig().getServerConnectTimeout());
+    }
+    public void connect(ServerInfo info, final Callback<Boolean> callback, final boolean retry, int timeout) {
+        connect(info, callback, retry, ServerConnectEvent.Reason.PLUGIN, timeout);
+    }
+
+    public void connect(ServerInfo info, final Callback<Boolean> callback, final boolean retry, ServerConnectEvent.Reason reason, final int timeout) {
+        this.connect(info, callback, retry, reason, timeout, true);
+    }
+
+    public void connect(ServerInfo info, final Callback<Boolean> callback, final boolean retry, ServerConnectEvent.Reason reason, final int timeout, boolean sendFeedback)
+    {
+        // Waterfall end
         Preconditions.checkNotNull( info, "info" );
 
-        ServerConnectRequest.Builder builder = ServerConnectRequest.builder().retry( retry ).reason( reason ).target( info );
+        ServerConnectRequest.Builder builder = ServerConnectRequest.builder().retry( retry ).reason( reason ).target( info ).sendFeedback(sendFeedback); // Waterfall - feedback param
+        builder.connectTimeout(timeout); // Waterfall
         if ( callback != null )
         {
             // Convert the Callback<Boolean> to be compatible with Callback<Result> from ServerConnectRequest.
@@ -332,7 +356,7 @@ public final class UserConnection implements ProxiedPlayer
                 callback.done( ServerConnectRequest.Result.ALREADY_CONNECTED, null );
             }
 
-            sendMessage( bungee.getTranslation( "already_connected" ) );
+            if (request.isSendFeedback()) sendMessage( bungee.getTranslation( "already_connected" ) ); // Waterfall
             return;
         }
         if ( pendingConnects.contains( target ) )
@@ -342,7 +366,7 @@ public final class UserConnection implements ProxiedPlayer
                 callback.done( ServerConnectRequest.Result.ALREADY_CONNECTING, null );
             }
 
-            sendMessage( bungee.getTranslation( "already_connecting" ) );
+            if (request.isSendFeedback()) sendMessage( bungee.getTranslation( "already_connecting" ) ); // Waterfall
             return;
         }
 
@@ -378,20 +402,20 @@ public final class UserConnection implements ProxiedPlayer
                     ServerInfo def = updateAndGetNextServer( target );
                     if ( request.isRetry() && def != null && ( getServer() == null || def != getServer().getInfo() ) )
                     {
-                        sendMessage( bungee.getTranslation( "fallback_lobby" ) );
-                        connect( def, null, true, ServerConnectEvent.Reason.LOBBY_FALLBACK );
+                        if (request.isSendFeedback()) sendMessage( bungee.getTranslation( "fallback_lobby" ) ); // Waterfall
+                        connect( def, null, true, ServerConnectEvent.Reason.LOBBY_FALLBACK, request.getConnectTimeout(), request.isSendFeedback() ); // Waterfall
                     } else if ( dimensionChange )
                     {
                         disconnect( bungee.getTranslation( "fallback_kick", connectionFailMessage( future.cause() ) ) );
                     } else
                     {
-                        sendMessage( bungee.getTranslation( "fallback_kick", connectionFailMessage( future.cause() ) ) );
+                        if (request.isSendFeedback()) sendMessage( bungee.getTranslation( "fallback_kick", connectionFailMessage( future.cause() ) ) );
                     }
                 }
             }
         };
         Bootstrap b = new Bootstrap()
-                .channel( PipelineUtils.getChannel( target.getAddress() ) )
+                .channelFactory( PipelineUtils.getChannelFactory( target.getAddress() ) ) // Waterfall - netty reflection -> factory
                 .group( ch.getHandle().eventLoop() )
                 .handler( initializer )
                 .option( ChannelOption.CONNECT_TIMEOUT_MILLIS, request.getConnectTimeout() )
@@ -406,7 +430,8 @@ public final class UserConnection implements ProxiedPlayer
 
     private String connectionFailMessage(Throwable cause)
     {
-        return groups.contains( "admin" ) ? Util.exception( cause, false ) : cause.getClass().getName();
+        bungee.getLogger().log(Level.WARNING, "Error occurred processing connection for " + this.name + " " + Util.exception( cause, false )); // Waterfall
+        return ""; // Waterfall
     }
 
     @Override
@@ -801,4 +826,9 @@ public final class UserConnection implements ProxiedPlayer
 
         unsafe().sendPacket( new Transfer( host, port ) );
     }
+    // Waterfall start
+    public boolean isDisableEntityMetadataRewrite() {
+        return entityRewrite == net.md_5.bungee.entitymap.EntityMap_Dummy.INSTANCE;
+    }
+    // Waterfall end
 }
diff --git a/proxy/src/main/java/net/md_5/bungee/command/CommandBungee.java b/proxy/src/main/java/net/md_5/bungee/command/CommandBungee.java
index b0798791..b26035cf 100644
--- a/proxy/src/main/java/net/md_5/bungee/command/CommandBungee.java
+++ b/proxy/src/main/java/net/md_5/bungee/command/CommandBungee.java
@@ -16,6 +16,6 @@ public class CommandBungee extends Command
     @Override
     public void execute(CommandSender sender, String[] args)
     {
-        sender.sendMessage( ChatColor.BLUE + "This server is running BungeeCord version " + ProxyServer.getInstance().getVersion() + " by md_5" );
+        sender.sendMessage( ChatColor.BLUE + "This server is running Waterfall version " + ProxyServer.getInstance().getVersion() + " by md_5" );
     }
 }
diff --git a/proxy/src/main/java/net/md_5/bungee/command/CommandReload.java b/proxy/src/main/java/net/md_5/bungee/command/CommandReload.java
index efe048c9..720d0c3b 100644
--- a/proxy/src/main/java/net/md_5/bungee/command/CommandReload.java
+++ b/proxy/src/main/java/net/md_5/bungee/command/CommandReload.java
@@ -23,7 +23,7 @@ public class CommandReload extends Command
         BungeeCord.getInstance().startListeners();
         BungeeCord.getInstance().getPluginManager().callEvent( new ProxyReloadEvent( sender ) );
 
-        sender.sendMessage( ChatColor.BOLD.toString() + ChatColor.RED.toString() + "BungeeCord has been reloaded."
-                + " This is NOT advisable and you will not be supported with any issues that arise! Please restart BungeeCord ASAP." );
+        sender.sendMessage( ChatColor.BOLD.toString() + ChatColor.RED.toString() + "Waterfall has been reloaded."
+                + " This is NOT advisable and you will not be supported with any issues that arise! Please restart Waterfall ASAP." );
     }
 }
diff --git a/proxy/src/main/java/net/md_5/bungee/command/ConsoleCommandCompleter.java b/proxy/src/main/java/net/md_5/bungee/command/ConsoleCommandCompleter.java
deleted file mode 100644
index 3e5ca394..00000000
--- a/proxy/src/main/java/net/md_5/bungee/command/ConsoleCommandCompleter.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package net.md_5.bungee.command;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.stream.Collectors;
-import jline.console.completer.Completer;
-import lombok.RequiredArgsConstructor;
-import net.md_5.bungee.api.ProxyServer;
-
-@RequiredArgsConstructor
-public class ConsoleCommandCompleter implements Completer
-{
-
-    private final ProxyServer proxy;
-
-    @Override
-    public int complete(String buffer, int cursor, List<CharSequence> candidates)
-    {
-        int lastSpace = buffer.lastIndexOf( ' ' );
-        if ( lastSpace == -1 )
-        {
-            String lowerCase = buffer.toLowerCase( Locale.ROOT );
-            candidates.addAll( proxy.getPluginManager().getCommands().stream()
-                    .map( Map.Entry::getKey )
-                    .filter( (name) -> name.toLowerCase( Locale.ROOT ).startsWith( lowerCase ) )
-                    .collect( Collectors.toList() ) );
-        } else
-        {
-            List<String> suggestions = new ArrayList<>();
-            proxy.getPluginManager().dispatchCommand( proxy.getConsole(), buffer, suggestions );
-            candidates.addAll( suggestions );
-        }
-
-        return ( lastSpace == -1 ) ? cursor - buffer.length() : cursor - ( buffer.length() - lastSpace - 1 );
-    }
-}
diff --git a/proxy/src/main/java/net/md_5/bungee/compress/PacketDecompressor.java b/proxy/src/main/java/net/md_5/bungee/compress/PacketDecompressor.java
index 445ee947..eaedf4bc 100644
--- a/proxy/src/main/java/net/md_5/bungee/compress/PacketDecompressor.java
+++ b/proxy/src/main/java/net/md_5/bungee/compress/PacketDecompressor.java
@@ -1,5 +1,7 @@
 package net.md_5.bungee.compress;
 
+import lombok.*;
+
 import com.google.common.base.Preconditions;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
@@ -8,9 +10,11 @@ import java.util.List;
 import net.md_5.bungee.jni.zlib.BungeeZlib;
 import net.md_5.bungee.protocol.DefinedPacket;
 
+@RequiredArgsConstructor
 public class PacketDecompressor extends MessageToMessageDecoder<ByteBuf>
 {
 
+    private final int compressionThreshold;
     private final BungeeZlib zlib = CompressFactory.zlib.newInstance();
 
     @Override
@@ -34,12 +38,13 @@ public class PacketDecompressor extends MessageToMessageDecoder<ByteBuf>
             out.add( in.retain() );
         } else
         {
+            Preconditions.checkArgument( size >= compressionThreshold, "Decompressed size %s less than compression threshold %s", size, compressionThreshold);
             ByteBuf decompressed = ctx.alloc().directBuffer();
 
             try
             {
                 zlib.process( in, decompressed );
-                Preconditions.checkState( decompressed.readableBytes() == size, "Decompressed packet size mismatch" );
+                Preconditions.checkArgument( decompressed.readableBytes() == size, "Decompressed size %s is not equal to actual decompressed bytes", size, decompressed.readableBytes());
 
                 out.add( decompressed );
                 decompressed = null;
diff --git a/proxy/src/main/java/net/md_5/bungee/conf/Configuration.java b/proxy/src/main/java/net/md_5/bungee/conf/Configuration.java
index 6967d4fc..a468c5c4 100644
--- a/proxy/src/main/java/net/md_5/bungee/conf/Configuration.java
+++ b/proxy/src/main/java/net/md_5/bungee/conf/Configuration.java
@@ -1,6 +1,7 @@
 package net.md_5.bungee.conf;
 
 import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableMap; // Waterfall
 import gnu.trove.map.TMap;
 import java.io.File;
 import java.io.IOException;
@@ -11,12 +12,16 @@ import java.util.UUID;
 import java.util.logging.Level;
 import javax.imageio.ImageIO;
 import lombok.Getter;
+import lombok.Synchronized; // Waterfall
+
+import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.api.Favicon;
 import net.md_5.bungee.api.ProxyConfig;
 import net.md_5.bungee.api.ProxyServer;
 import net.md_5.bungee.api.config.ConfigurationAdapter;
 import net.md_5.bungee.api.config.ListenerInfo;
 import net.md_5.bungee.api.config.ServerInfo;
+import net.md_5.bungee.api.connection.ProxiedPlayer;
 import net.md_5.bungee.util.CaseInsensitiveMap;
 import net.md_5.bungee.util.CaseInsensitiveSet;
 
@@ -24,7 +29,7 @@ import net.md_5.bungee.util.CaseInsensitiveSet;
  * Core configuration for the proxy.
  */
 @Getter
-public class Configuration implements ProxyConfig
+public abstract class Configuration implements ProxyConfig
 {
 
     /**
@@ -39,6 +44,7 @@ public class Configuration implements ProxyConfig
      * Set of all listeners.
      */
     private Collection<ListenerInfo> listeners;
+    private final Object serversLock = new Object(); // Waterfall
     /**
      * Set of all servers.
      */
@@ -67,9 +73,10 @@ public class Configuration implements ProxyConfig
     private Favicon favicon;
     private int compressionThreshold = 256;
     private boolean preventProxyConnections;
-    private boolean forgeSupport;
     private boolean rejectTransfers;
+    private boolean forgeSupport = true; // Waterfall: default to enabled
 
+    @Synchronized("serversLock") // Waterfall
     public void load()
     {
         ConfigurationAdapter adapter = ProxyServer.getInstance().getConfigurationAdapter();
@@ -118,20 +125,38 @@ public class Configuration implements ProxyConfig
             servers = new CaseInsensitiveMap<>( newServers );
         } else
         {
-            for ( ServerInfo oldServer : servers.values() )
-            {
-                // Don't allow servers to be removed
-                Preconditions.checkArgument( newServers.containsKey( oldServer.getName() ), "Server %s removed on reload!", oldServer.getName() );
-            }
+            Map<String, ServerInfo> oldServers = getServersCopy();
 
-            // Add new servers
-            for ( Map.Entry<String, ServerInfo> newServer : newServers.entrySet() )
+            for ( ServerInfo oldServer : oldServers.values() )
             {
-                if ( !servers.containsValue( newServer.getValue() ) )
-                {
-                    servers.put( newServer.getKey(), newServer.getValue() );
+                ServerInfo newServer = newServers.get(oldServer.getName());
+                if ((newServer == null || !oldServer.getAddress().equals(newServer.getAddress())) && !oldServer.getPlayers().isEmpty()) {
+                    BungeeCord.getInstance().getLogger().info("Moving players off of server: " + oldServer.getName());
+                    // The server is being removed, or having it's address changed
+                    for (ProxiedPlayer player : oldServer.getPlayers()) {
+                        ListenerInfo listener = player.getPendingConnection().getListener();
+                        String destinationName = newServers.get(listener.getDefaultServer()) == null ? listener.getDefaultServer() : listener.getFallbackServer();
+                        ServerInfo destination = newServers.get(destinationName);
+                        if (destination == null) {
+                            BungeeCord.getInstance().getLogger().severe("Couldn't find server " + listener.getDefaultServer() + " or " + listener.getFallbackServer() + " to put player " + player.getName() + " on");
+                            player.disconnect(BungeeCord.getInstance().getTranslation("fallback_kick", "Not found on reload"));
+                            continue;
+                        }
+                        player.connect(destination, (success, cause) -> {
+                            if (!success) {
+                                BungeeCord.getInstance().getLogger().log(Level.WARNING, "Failed to connect " + player.getName() + " to " + destination.getName(), cause);
+                                player.disconnect(BungeeCord.getInstance().getTranslation("fallback_kick", cause.getCause().getClass().getName()));
+                            }
+                        });
+                    }
+                } else {
+                    // This server isn't new or removed, we'll use bungees behavior of just ignoring
+                    // any changes to info outside of the address, this is not ideal, but the alternative
+                    // requires resetting multiple objects of which have no proper identity
+                    newServers.put(oldServer.getName(), oldServer);
                 }
             }
+            this.servers = new CaseInsensitiveMap<>(newServers);
         }
 
         for ( ListenerInfo listener : listeners )
@@ -163,4 +188,71 @@ public class Configuration implements ProxyConfig
     {
         return favicon;
     }
+
+    // Waterfall start
+    @Override
+    @Synchronized("serversLock")
+    public Map<String, ServerInfo> getServersCopy() {
+        return ImmutableMap.copyOf( servers );
+    }
+
+    @Override
+    @Synchronized("serversLock")
+    public ServerInfo getServerInfo(String name)
+    {
+        return this.servers.get( name );
+    }
+
+    @Override
+    @Synchronized("serversLock")
+    public ServerInfo addServer(ServerInfo server)
+    {
+        return this.servers.put( server.getName(), server );
+    }
+
+    @Override
+    @Synchronized("serversLock")
+    public boolean addServers(Collection<ServerInfo> servers)
+    {
+        boolean changed = false;
+        for ( ServerInfo server : servers )
+        {
+            if ( server != this.servers.put( server.getName(), server ) ) changed = true;
+        }
+        return changed;
+    }
+
+    @Override
+    @Synchronized("serversLock")
+    public ServerInfo removeServerNamed(String name)
+    {
+        return this.servers.remove( name );
+    }
+
+    @Override
+    @Synchronized("serversLock")
+    public ServerInfo removeServer(ServerInfo server)
+    {
+        return this.servers.remove( server.getName() );
+    }
+
+    @Override
+    @Synchronized("serversLock")
+    public boolean removeServersNamed(Collection<String> names)
+    {
+        return this.servers.keySet().removeAll( names );
+    }
+
+    @Override
+    @Synchronized("serversLock")
+    public boolean removeServers(Collection<ServerInfo> servers)
+    {
+        boolean changed = false;
+        for ( ServerInfo server : servers )
+        {
+            if ( null != this.servers.remove( server.getName() ) ) changed = true;
+        }
+        return changed;
+    }
+    // Waterfall end
 }
diff --git a/proxy/src/main/java/net/md_5/bungee/conf/YamlConfig.java b/proxy/src/main/java/net/md_5/bungee/conf/YamlConfig.java
index d659a138..1de9875c 100644
--- a/proxy/src/main/java/net/md_5/bungee/conf/YamlConfig.java
+++ b/proxy/src/main/java/net/md_5/bungee/conf/YamlConfig.java
@@ -47,10 +47,15 @@ public class YamlConfig implements ConfigurationAdapter
     }
     private final Yaml yaml;
     private Map<String, Object> config;
-    private final File file = new File( "config.yml" );
+    private final File file;
 
-    public YamlConfig()
+    public YamlConfig() {
+        this(new File("config.yml"));
+    }
+
+    public YamlConfig(File file)
     {
+        this.file = file;
         DumperOptions options = new DumperOptions();
         options.setDefaultFlowStyle( DumperOptions.FlowStyle.BLOCK );
         yaml = new Yaml( options );
@@ -58,6 +63,11 @@ public class YamlConfig implements ConfigurationAdapter
 
     @Override
     public void load()
+    {
+        load(true);
+    }
+
+    public void load(boolean doPermissions)
     {
         try
         {
@@ -86,6 +96,7 @@ public class YamlConfig implements ConfigurationAdapter
             throw new RuntimeException( "Could not load configuration!", ex );
         }
 
+        if(!doPermissions) return; // Waterfall
         Map<String, Object> permissions = get( "permissions", null );
         if ( permissions == null )
         {
@@ -216,7 +227,7 @@ public class YamlConfig implements ConfigurationAdapter
             Map<String, Object> val = entry.getValue();
             String name = entry.getKey();
             String addr = get( "address", "localhost:25565", val );
-            String motd = ChatColor.translateAlternateColorCodes( '&', get( "motd", "&1Just another BungeeCord - Forced Host", val ) );
+            String motd = ChatColor.translateAlternateColorCodes( '&', get( "motd", "&1Just another Waterfall - Forced Host", val ) );
             boolean restricted = get( "restricted", false, val );
             SocketAddress address = Util.getAddr( addr );
             ServerInfo info = ProxyServer.getInstance().constructServerInfo( name, address, motd, restricted );
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java b/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java
index d518d05f..a96870a7 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java
@@ -98,16 +98,18 @@ public class DownstreamBridge extends PacketHandler
             return;
         }
 
+        // Waterfall start
         ServerInfo def = con.updateAndGetNextServer( server.getInfo() );
-        if ( def != null )
+        ServerKickEvent event = bungee.getPluginManager().callEvent( new ServerKickEvent( con, server.getInfo(), TextComponent.fromLegacyText( bungee.getTranslation( "server_went_down" ) ), def, ServerKickEvent.State.CONNECTED, ServerKickEvent.Cause.EXCEPTION ) );
+        if ( event.isCancelled() && event.getCancelServer() != null )
         {
             server.setObsolete( true );
-            con.connectNow( def, ServerConnectEvent.Reason.SERVER_DOWN_REDIRECT );
-            con.sendMessage( bungee.getTranslation( "server_went_down", def.getName() ) );
+            con.connectNow( event.getCancelServer(), ServerConnectEvent.Reason.SERVER_DOWN_REDIRECT );
         } else
         {
-            con.disconnect( Util.exception( t ) );
+            con.disconnect0( event.getReason() );
         }
+        // Waterfall end
     }
 
     @Override
@@ -129,16 +131,18 @@ public class DownstreamBridge extends PacketHandler
             return;
         }
 
+        // Waterfall start
         ServerInfo def = con.updateAndGetNextServer( server.getInfo() );
-        if ( def != null )
+        ServerKickEvent event = bungee.getPluginManager().callEvent( new ServerKickEvent( con, server.getInfo(), TextComponent.fromLegacyText( bungee.getTranslation( "lost_connection" ) ), def, ServerKickEvent.State.CONNECTED, ServerKickEvent.Cause.LOST_CONNECTION ) );
+        if ( event.isCancelled() && event.getCancelServer() != null )
         {
             server.setObsolete( true );
-            con.connectNow( def, ServerConnectEvent.Reason.SERVER_DOWN_REDIRECT );
-            con.sendMessage( bungee.getTranslation( "server_went_down", def.getName() ) );
+            con.connectNow( event.getCancelServer(), ServerConnectEvent.Reason.SERVER_DOWN_REDIRECT );
         } else
         {
-            con.disconnect( bungee.getTranslation( "lost_connection" ) );
+            con.disconnect0( event.getReason() );
         }
+        // Waterfall end
     }
 
     @Override
@@ -171,8 +175,14 @@ public class DownstreamBridge extends PacketHandler
     @Override
     public void handle(PlayerListItem playerList) throws Exception
     {
-        con.getTabListHandler().onUpdate( TabList.rewrite( playerList ) );
-        throw CancelSendSignal.INSTANCE; // Always throw because of profile rewriting
+        //Waterfall start
+        boolean skipRewrites = bungee.getConfig().isDisableTabListRewrite();
+        con.getTabListHandler().onUpdate( skipRewrites ? playerList : TabList.rewrite( playerList ) );
+        if ( !skipRewrites )
+        {
+            throw CancelSendSignal.INSTANCE; // Only throw if profile rewriting is enabled
+        }
+        // Waterfall end
     }
 
     @Override
@@ -307,7 +317,6 @@ public class DownstreamBridge extends PacketHandler
     @SuppressWarnings("checkstyle:avoidnestedblocks")
     public void handle(PluginMessage pluginMessage) throws Exception
     {
-        DataInput in = pluginMessage.getStream();
         PluginMessageEvent event = new PluginMessageEvent( server, con, pluginMessage.getTag(), pluginMessage.getData().clone() );
 
         if ( bungee.getPluginManager().callEvent( event ).isCancelled() )
@@ -324,8 +333,8 @@ public class DownstreamBridge extends PacketHandler
             Preconditions.checkState( !serverBrand.contains( bungee.getName() ), "Cannot connect proxy to itself!" );
 
             brand = ByteBufAllocator.DEFAULT.heapBuffer();
-            DefinedPacket.writeString( bungee.getName() + " (" + bungee.getVersion() + ")" + " <- " + serverBrand, brand );
-            pluginMessage.setData( DefinedPacket.toArray( brand ) );
+            DefinedPacket.writeString( bungee.getName() + " <- " + serverBrand, brand ); // Waterfall
+            pluginMessage.setData( brand );
             brand.release();
             // changes in the packet are ignored so we need to send it manually
             con.unsafe().sendPacket( pluginMessage );
@@ -334,6 +343,7 @@ public class DownstreamBridge extends PacketHandler
 
         if ( pluginMessage.getTag().equals( "BungeeCord" ) )
         {
+            DataInput in = pluginMessage.getStream();
             ByteArrayDataOutput out = ByteStreams.newDataOutput();
             String subChannel = in.readUTF();
 
@@ -645,10 +655,14 @@ public class DownstreamBridge extends PacketHandler
     public void handle(Kick kick) throws Exception
     {
         ServerInfo def = con.updateAndGetNextServer( server.getInfo() );
+        if ( java.util.Objects.equals( server.getInfo(), def ) )
+        {
+            def = null;
+        }
         ServerKickEvent event = bungee.getPluginManager().callEvent( new ServerKickEvent( con, server.getInfo(), new BaseComponent[]
         {
             kick.getMessage()
-        }, def, ServerKickEvent.State.CONNECTED ) );
+        }, def, ServerKickEvent.State.CONNECTED, ServerKickEvent.Cause.SERVER ) ); // Waterfall
         if ( event.isCancelled() && event.getCancelServer() != null )
         {
             con.connectNow( event.getCancelServer(), ServerConnectEvent.Reason.KICK_REDIRECT );
@@ -746,6 +760,34 @@ public class DownstreamBridge extends PacketHandler
         }
     }
 
+    // Waterfall start
+    @Override
+    public void handle(net.md_5.bungee.protocol.packet.EntityEffect entityEffect) throws Exception
+    {
+        if (con.isDisableEntityMetadataRewrite()) return; // Waterfall
+        // Don't send any potions when switching between servers (which involves a handshake), which can trigger a race
+        // condition on the client.
+        if (this.con.getForgeClientHandler().isForgeUser() && !this.con.getForgeClientHandler().isHandshakeComplete()) {
+            throw CancelSendSignal.INSTANCE;
+        }
+        con.getPotions().put(rewriteEntityId(entityEffect.getEntityId()), entityEffect.getEffectId());
+    }
+
+    @Override
+    public void handle(net.md_5.bungee.protocol.packet.EntityRemoveEffect removeEffect) throws Exception
+    {
+        if (con.isDisableEntityMetadataRewrite()) return; // Waterfall
+        con.getPotions().remove(rewriteEntityId(removeEffect.getEntityId()), removeEffect.getEffectId());
+    }
+
+    private int rewriteEntityId(int entityId) {
+        if (entityId == con.getServerEntityId()) {
+            return con.getClientEntityId();
+        }
+        return entityId;
+    }
+    // Waterfall end
+
     @Override
     public void handle(Respawn respawn)
     {
@@ -757,9 +799,25 @@ public class DownstreamBridge extends PacketHandler
     {
         boolean modified = false;
 
-        for ( Map.Entry<String, Command> command : bungee.getPluginManager().getCommands() )
+        // Waterfall start
+        Map<String, Command> commandMap = new java.util.HashMap<>();
+        for ( Map.Entry<String, Command> commandEntry : bungee.getPluginManager().getCommands() ) {
+            if ( !bungee.getDisabledCommands().contains( commandEntry.getKey() )
+                    && commands.getRoot().getChild( commandEntry.getKey() ) == null
+                    && commandEntry.getValue().hasPermission( this.con ) ) {
+
+                commandMap.put( commandEntry.getKey(), commandEntry.getValue() );
+            }
+        }
+
+        io.github.waterfallmc.waterfall.event.ProxyDefineCommandsEvent event = new io.github.waterfallmc.waterfall.event.ProxyDefineCommandsEvent( this.server, this.con, commandMap );
+        bungee.getPluginManager().callEvent( event );
+
+        for ( Map.Entry<String, Command> command : event.getCommands().entrySet() )
         {
-            if ( !bungee.getDisabledCommands().contains( command.getKey() ) && commands.getRoot().getChild( command.getKey() ) == null && command.getValue().hasPermission( con ) )
+            //noinspection ConstantConditions
+            if ( true ) // Moved up
+            // Waterfall end
             {
                 CommandNode dummy = LiteralArgumentBuilder.literal( command.getKey() ).executes( DUMMY_COMMAND )
                         .then( RequiredArgumentBuilder.argument( "args", StringArgumentType.greedyString() )
@@ -802,6 +860,6 @@ public class DownstreamBridge extends PacketHandler
     @Override
     public String toString()
     {
-        return "[" + con.getName() + "] <-> DownstreamBridge <-> [" + server.getInfo().getName() + "]";
+        return "[" + con.getAddress() + "|" + con.getName() + "] <-> DownstreamBridge <-> [" + server.getInfo().getName() + "]";
     }
 }
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
index 224f231b..185e63ad 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
@@ -23,6 +23,8 @@ import javax.crypto.SecretKey;
 import lombok.AllArgsConstructor;
 import lombok.Data;
 import lombok.EqualsAndHashCode;
+import javax.crypto.spec.SecretKeySpec;
+
 import lombok.Getter;
 import lombok.RequiredArgsConstructor;
 import lombok.ToString;
@@ -85,6 +87,8 @@ import net.md_5.bungee.util.QuietException;
 public class InitialHandler extends PacketHandler implements PendingConnection
 {
 
+    private static final String MOJANG_AUTH_URL = System.getProperty("waterfall.auth.url", "https://sessionserver.mojang.com/session/minecraft/hasJoined?username=%s&serverId=%s%s");
+
     private final BungeeCord bungee;
     private ChannelWrapper ch;
     @Getter
@@ -190,7 +194,17 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     @Override
     public void handle(PluginMessage pluginMessage) throws Exception
     {
-        this.relayMessage( pluginMessage );
+        // Waterfall start
+        try {
+            this.relayMessage(pluginMessage);
+        } catch (IllegalStateException | IllegalArgumentException ex) {
+            if (net.md_5.bungee.protocol.MinecraftDecoder.DEBUG) {
+                throw ex;
+            } else {
+                throw new QuietException(ex.getMessage());
+            }
+        }
+        // Waterfall end
     }
 
     @Override
@@ -333,10 +347,14 @@ public class InitialHandler extends PacketHandler implements PendingConnection
         thisState = State.PING;
     }
 
+    private static final boolean ACCEPT_INVALID_PACKETS = Boolean.parseBoolean(System.getProperty("waterfall.acceptInvalidPackets", "false"));
+
     @Override
     public void handle(PingPacket ping) throws Exception
     {
-        Preconditions.checkState( thisState == State.PING, "Not expecting PING" );
+        if (!ACCEPT_INVALID_PACKETS) {
+            Preconditions.checkState(thisState == State.PING, "Not expecting PING");
+        }
         unsafe.sendPacket( ping );
         disconnect( "" );
     }
@@ -392,7 +410,10 @@ public class InitialHandler extends PacketHandler implements PendingConnection
             case 3:
                 transferred = handshake.getRequestedProtocol() == 3;
                 // Login
-                bungee.getLogger().log( Level.INFO, "{0} has connected", this );
+                if (BungeeCord.getInstance().getConfig().isLogInitialHandlerConnections() ) // Waterfall
+                {
+                    bungee.getLogger().log( Level.INFO, "{0} has connected", this );
+                }
                 thisState = State.USERNAME;
                 ch.setProtocol( Protocol.LOGIN );
 
@@ -432,6 +453,7 @@ public class InitialHandler extends PacketHandler implements PendingConnection
 
         if ( BungeeCord.getInstance().config.isEnforceSecureProfile() && getVersion() < ProtocolConstants.MINECRAFT_1_19_3 )
         {
+            if ( handshake.getProtocolVersion() < ProtocolConstants.MINECRAFT_1_19 ) {disconnect(bungee.getTranslation("secure_profile_unsupported"));} // Waterfall - Tell old clients to update if secure profiles are required
             PlayerPublicKey publicKey = loginRequest.getPublicKey();
             if ( publicKey == null )
             {
@@ -509,8 +531,17 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     {
         Preconditions.checkState( thisState == State.ENCRYPT, "Not expecting ENCRYPT" );
         Preconditions.checkState( EncryptionUtil.check( loginRequest.getPublicKey(), encryptResponse, request ), "Invalid verification" );
+        thisState = State.FINISHING; // Waterfall - move earlier - There is no verification of this later (and this is not API)
 
         SecretKey sharedKey = EncryptionUtil.getSecret( encryptResponse, request );
+        // Waterfall start
+        if (sharedKey instanceof SecretKeySpec) {
+            if (sharedKey.getEncoded().length != 16) {
+             this.ch.close();
+             return;
+            }
+        }
+        // Waterfall end
         BungeeCipher decrypt = EncryptionUtil.getCipher( false, sharedKey );
         ch.addBefore( PipelineUtils.FRAME_DECODER, PipelineUtils.DECRYPT_HANDLER, new CipherDecoder( decrypt ) );
         BungeeCipher encrypt = EncryptionUtil.getCipher( true, sharedKey );
@@ -531,7 +562,7 @@ public class InitialHandler extends PacketHandler implements PendingConnection
         String encodedHash = URLEncoder.encode( new BigInteger( sha.digest() ).toString( 16 ), "UTF-8" );
 
         String preventProxy = ( BungeeCord.getInstance().config.isPreventProxyConnections() && getSocketAddress() instanceof InetSocketAddress ) ? "&ip=" + URLEncoder.encode( getAddress().getAddress().getHostAddress(), "UTF-8" ) : "";
-        String authURL = "https://sessionserver.mojang.com/session/minecraft/hasJoined?username=" + encName + "&serverId=" + encodedHash + preventProxy;
+        String authURL = String.format( MOJANG_AUTH_URL, encName, encodedHash, preventProxy );
 
         Callback<String> handler = new Callback<String>()
         {
@@ -557,7 +588,7 @@ public class InitialHandler extends PacketHandler implements PendingConnection
                 }
             }
         };
-        thisState = State.FINISHING;
+        //thisState = State.FINISHING; // Waterfall - move earlier
         HttpClient.get( authURL, ch.getHandle().eventLoop(), handler );
     }
 
@@ -649,7 +680,7 @@ public class InitialHandler extends PacketHandler implements PendingConnection
         };
 
         // fire login event
-        bungee.getPluginManager().callEvent( new LoginEvent( InitialHandler.this, complete ) );
+        bungee.getPluginManager().callEvent( new LoginEvent( InitialHandler.this, complete, this.getLoginProfile() ) ); // Waterfall: Parse LoginResult object to new constructor of LoginEvent
     }
 
     private void finish2()
@@ -823,26 +854,13 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     @Override
     public String getUUID()
     {
-        return uniqueId.toString().replace( "-", "" );
+        return io.github.waterfallmc.waterfall.utils.UUIDUtils.undash( uniqueId.toString() ); // Waterfall
     }
 
     @Override
     public String toString()
     {
-        StringBuilder sb = new StringBuilder();
-        sb.append( '[' );
-
-        String currentName = getName();
-        if ( currentName != null )
-        {
-            sb.append( currentName );
-            sb.append( ',' );
-        }
-
-        sb.append( getSocketAddress() );
-        sb.append( "] <-> InitialHandler" );
-
-        return sb.toString();
+        return "[" + getSocketAddress() + ( getName() != null ? "|" + getName() : "" ) + "] <-> InitialHandler";
     }
 
     @Override
@@ -859,9 +877,10 @@ public class InitialHandler extends PacketHandler implements PendingConnection
 
             for ( String id : content.split( "\0" ) )
             {
-                Preconditions.checkState( registeredChannels.size() < 128, "Too many registered channels" );
-                Preconditions.checkArgument( id.length() < 128, "Channel name too long" );
-
+                // Waterfall start: Add configurable limits for plugin messaging
+                Preconditions.checkState( !(registeredChannels.size() > bungee.getConfig().getPluginChannelLimit()), "Too many registered channels. This limit can be configured in the waterfall.yml" );
+                Preconditions.checkArgument( !(id.length() > bungee.getConfig().getPluginChannelNameLimit()), "Channel name too long. This limit can be configured in the waterfall.yml" );
+                // Waterfall end
                 registeredChannels.add( id );
             }
         } else if ( input.getTag().equals( "UNREGISTER" ) || input.getTag().equals( "minecraft:unregister" ) )
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
index 5c1cf858..b482fe2e 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
@@ -51,6 +51,8 @@ public class UpstreamBridge extends PacketHandler
     private final ProxyServer bungee;
     private final UserConnection con;
 
+    private long lastTabCompletion = -1;
+
     public UpstreamBridge(ProxyServer bungee, UserConnection con)
     {
         this.bungee = bungee;
@@ -194,16 +196,22 @@ public class UpstreamBridge extends PacketHandler
     @Override
     public void handle(ClientCommand command) throws Exception
     {
-        handleChat( "/" + command.getCommand() );
+        handleChat( "/" + command.getCommand(), command );
     }
 
     @Override
     public void handle(UnsignedClientCommand command) throws Exception
     {
-        handleChat( "/" + command.getCommand() );
+        handleChat( "/" + command.getCommand(), null); // Waterfall
     }
 
     private String handleChat(String message)
+    {
+        // Waterfall start
+        return handleChat(message, null);
+    }
+    private String handleChat(String message, @javax.annotation.Nullable ClientCommand clientCommand)
+    // Waterfall end
     {
         for ( int index = 0, length = message.length(); index < length; index++ )
         {
@@ -222,7 +230,13 @@ public class UpstreamBridge extends PacketHandler
             if ( !chatEvent.isCommand() || !bungee.getPluginManager().dispatchCommand( con, message.substring( 1 ) ) )
             {
                 return message;
+                // Waterfall start - We're going to cancel this packet, so, no matter what, we might as well try to send this
+            } else if (clientCommand != null && clientCommand.isSigned() && clientCommand.getSeenMessages() != null) {
+                if (con.getPendingConnection().getVersion() >= ProtocolConstants.MINECRAFT_1_19_3) {
+                    con.getServer().unsafe().sendPacket(new net.md_5.bungee.protocol.packet.ClientChatAcknowledgement(clientCommand.getSeenMessages().getOffset()));
+                }
             }
+            // Waterfall end
         }
         throw CancelSendSignal.INSTANCE;
     }
@@ -230,6 +244,20 @@ public class UpstreamBridge extends PacketHandler
     @Override
     public void handle(TabCompleteRequest tabComplete) throws Exception
     {
+        // Waterfall start - tab limiter
+        if ( bungee.getConfig().getTabThrottle() > 0 &&
+                ( con.getPendingConnection().getVersion() >= ProtocolConstants.MINECRAFT_1_13
+                && !bungee.getConfig().isDisableModernTabLimiter()))
+        {
+            long now = System.currentTimeMillis();
+            if ( lastTabCompletion > 0 && (now - lastTabCompletion) <= bungee.getConfig().getTabThrottle() )
+            {
+                throw CancelSendSignal.INSTANCE;
+            }
+            lastTabCompletion = now;
+        }
+
+        // Waterfall end - tab limiter
         List<String> suggestions = new ArrayList<>();
         boolean isRegisteredCommand = false;
         boolean isCommand = tabComplete.getCursor().startsWith( "/" );
@@ -380,6 +408,6 @@ public class UpstreamBridge extends PacketHandler
     @Override
     public String toString()
     {
-        return "[" + con.getName() + "] -> UpstreamBridge";
+        return "[" + con.getAddress() + "|" + con.getName() + "] -> UpstreamBridge";
     }
 }
diff --git a/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap.java b/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap.java
index 755b8fd6..0f9f5957 100644
--- a/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap.java
+++ b/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap.java
@@ -27,6 +27,11 @@ public abstract class EntityMap
     // Returns the correct entity map for the protocol version
     public static EntityMap getEntityMap(int version)
     {
+        // Waterfall start
+        if (net.md_5.bungee.api.ProxyServer.getInstance().getConfig().isDisableEntityMetadataRewrite()) {
+            return EntityMap_Dummy.INSTANCE;
+        }
+        // Waterfall end
         switch ( version )
         {
             case ProtocolConstants.MINECRAFT_1_8:
@@ -307,7 +312,13 @@ public abstract class EntityMap
                     DefinedPacket.readVarInt( packet );
                     break;
                 default:
-                    throw new IllegalArgumentException( "Unknown meta type " + type );
+                    // Waterfall start - Don't lie
+                    if ( protocolVersion >= ProtocolConstants.MINECRAFT_1_13 )
+                    {
+                        type++;
+                    }
+                    throw new IllegalArgumentException( "Unknown meta type " + type  + ": Using mods? refer to disable_entity_metadata_rewrite in waterfall.yml" );
+                    // Waterfall end
             }
         }
 
@@ -345,6 +356,12 @@ public abstract class EntityMap
         int packetId = DefinedPacket.readVarInt( packet );
         int packetIdLength = packet.readerIndex() - readerIndex;
 
+        if (packetId < 0 || packetId > ints.length || packetId > varints.length) { // Invalid packet id
+            // Ignore these invalid packets for compatibility reasons
+            packet.readerIndex( readerIndex );
+            return;
+        }
+
         if ( ints[packetId] )
         {
             rewriteInt( packet, oldId, newId, readerIndex + packetIdLength );
diff --git a/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap_Dummy.java b/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap_Dummy.java
new file mode 100644
index 00000000..cb81d1dd
--- /dev/null
+++ b/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap_Dummy.java
@@ -0,0 +1,30 @@
+
+package net.md_5.bungee.entitymap;
+
+import io.netty.buffer.ByteBuf;
+// Waterfall start
+
+public class EntityMap_Dummy extends EntityMap {
+
+    public static final EntityMap_Dummy INSTANCE = new EntityMap_Dummy();
+
+    EntityMap_Dummy() {
+    }
+
+    @Override
+    public void rewriteServerbound(ByteBuf packet, int oldId, int newId) {
+    }
+
+    @Override
+    public void rewriteServerbound(ByteBuf packet, int oldId, int newId, int protocolVersion) {
+    }
+
+    @Override
+    public void rewriteClientbound(ByteBuf packet, int oldId, int newId) {
+    }
+
+    @Override
+    public void rewriteClientbound(ByteBuf packet, int oldId, int newId, int protocolVersion) {
+    }
+}
+// Waterfall end
\ No newline at end of file
diff --git a/proxy/src/main/java/net/md_5/bungee/forge/ForgeClientHandler.java b/proxy/src/main/java/net/md_5/bungee/forge/ForgeClientHandler.java
index d15044f4..bea2bbff 100644
--- a/proxy/src/main/java/net/md_5/bungee/forge/ForgeClientHandler.java
+++ b/proxy/src/main/java/net/md_5/bungee/forge/ForgeClientHandler.java
@@ -9,6 +9,8 @@ import lombok.NonNull;
 import lombok.RequiredArgsConstructor;
 import lombok.Setter;
 import net.md_5.bungee.UserConnection;
+import net.md_5.bungee.protocol.ProtocolConstants;
+import net.md_5.bungee.protocol.packet.EntityRemoveEffect;
 import net.md_5.bungee.protocol.packet.PluginMessage;
 
 /**
@@ -94,9 +96,23 @@ public class ForgeClientHandler
     public void resetHandshake()
     {
         state = ForgeClientHandshakeState.HELLO;
+
+        // This issue only exists in Forge 1.8.9
+        if (this.con.getPendingConnection().getVersion() == ProtocolConstants.MINECRAFT_1_8) {
+            this.resetAllThePotions(con);
+        }
+
         con.unsafe().sendPacket( ForgeConstants.FML_RESET_HANDSHAKE );
     }
 
+    private void resetAllThePotions(UserConnection con) {
+        // Just to be sure
+        for (Map.Entry<Integer, Integer> entry: con.getPotions().entries()) {
+            con.unsafe().sendPacket(new EntityRemoveEffect(entry.getKey(), entry.getValue()));
+        }
+        con.getPotions().clear();
+    }
+
     /**
      * Sends the server mod list to the client, or stores it for sending later.
      *
diff --git a/proxy/src/main/java/net/md_5/bungee/forge/ForgeClientHandshakeState.java b/proxy/src/main/java/net/md_5/bungee/forge/ForgeClientHandshakeState.java
index 52429265..5e02f8c8 100644
--- a/proxy/src/main/java/net/md_5/bungee/forge/ForgeClientHandshakeState.java
+++ b/proxy/src/main/java/net/md_5/bungee/forge/ForgeClientHandshakeState.java
@@ -171,7 +171,8 @@ enum ForgeClientHandshakeState implements IForgeClientPacketHandler<ForgeClientH
         public ForgeClientHandshakeState handle(PluginMessage message, UserConnection con)
         {
             // Ack.
-            if ( message.getData()[0] == -1 )
+            if (( message.getTag().equals( ForgeConstants.FML_HANDSHAKE_TAG ) && message.getData()[0] == -1 )
+                    || message.getTag().equals( ForgeConstants.FORGE_REGISTER ))
             {
                 ForgeLogger.logClient( ForgeLogger.LogDirection.RECEIVED, this.name(), message );
                 con.unsafe().sendPacket( message );
@@ -187,7 +188,7 @@ enum ForgeClientHandshakeState implements IForgeClientPacketHandler<ForgeClientH
         }
     },
     /**
-     * Handshake has been completed. Ignores any future handshake packets.
+     * Handshake has been completed. Ignores any future handshake packets, but not any FORGE packets.
      */
     DONE
     {
@@ -196,6 +197,11 @@ enum ForgeClientHandshakeState implements IForgeClientPacketHandler<ForgeClientH
         public ForgeClientHandshakeState handle(PluginMessage message, UserConnection con)
         {
             ForgeLogger.logClient( ForgeLogger.LogDirection.RECEIVED, this.name(), message );
+            if ( message.getTag().equals( ForgeConstants.FORGE_REGISTER ))
+            {
+                con.unsafe().sendPacket( message );
+            }
+
             return this;
         }
 
diff --git a/proxy/src/main/java/net/md_5/bungee/forge/ForgeConstants.java b/proxy/src/main/java/net/md_5/bungee/forge/ForgeConstants.java
index 6dca2048..f5253b89 100644
--- a/proxy/src/main/java/net/md_5/bungee/forge/ForgeConstants.java
+++ b/proxy/src/main/java/net/md_5/bungee/forge/ForgeConstants.java
@@ -14,6 +14,10 @@ public class ForgeConstants
     public static final String FML_HANDSHAKE_TAG = "FML|HS";
     public static final String FML_REGISTER = "REGISTER";
 
+    // Game profile key
+    public static final String FML_LOGIN_PROFILE = "forgeClient";
+    public static final String EXTRA_DATA = "extraData";
+
     /**
      * The FML 1.8 handshake token.
      */
diff --git a/proxy/src/main/java/net/md_5/bungee/forge/ForgeServerHandler.java b/proxy/src/main/java/net/md_5/bungee/forge/ForgeServerHandler.java
index 77d18e6d..d254b84e 100644
--- a/proxy/src/main/java/net/md_5/bungee/forge/ForgeServerHandler.java
+++ b/proxy/src/main/java/net/md_5/bungee/forge/ForgeServerHandler.java
@@ -50,7 +50,7 @@ public class ForgeServerHandler
         ForgeServerHandshakeState prevState = state;
         packetQueue.add( message );
         state = state.send( message, con );
-        if ( state != prevState ) // send packets
+        if ( state == ForgeServerHandshakeState.DONE || state != prevState ) // send packets
         {
             synchronized ( packetQueue )
             {
diff --git a/proxy/src/main/java/net/md_5/bungee/http/HttpClient.java b/proxy/src/main/java/net/md_5/bungee/http/HttpClient.java
index e0c52f21..c3683c30 100644
--- a/proxy/src/main/java/net/md_5/bungee/http/HttpClient.java
+++ b/proxy/src/main/java/net/md_5/bungee/http/HttpClient.java
@@ -28,6 +28,10 @@ public class HttpClient
 
     public static final int TIMEOUT = 5000;
     private static final Cache<String, InetAddress> addressCache = CacheBuilder.newBuilder().expireAfterWrite( 1, TimeUnit.MINUTES ).build();
+    // Waterfall Start - optionally use async resolver from Netty
+    private static final io.netty.resolver.dns.DnsAddressResolverGroup dnsResolverGroup =
+            new io.netty.resolver.dns.DnsAddressResolverGroup(PipelineUtils.getDatagramChannel(), io.netty.resolver.dns.DefaultDnsServerAddressStreamProvider.INSTANCE);
+    // Waterfall End
 
     @SuppressWarnings("UnusedAssignment")
     public static void get(String url, EventLoop eventLoop, final Callback<String> callback)
@@ -57,19 +61,21 @@ public class HttpClient
             }
         }
 
-        InetAddress inetHost = addressCache.getIfPresent( uri.getHost() );
-        if ( inetHost == null )
-        {
-            try
-            {
-                inetHost = InetAddress.getByName( uri.getHost() );
-            } catch ( UnknownHostException ex )
-            {
-                callback.done( null, ex );
-                return;
-            }
-            addressCache.put( uri.getHost(), inetHost );
-        }
+        // Waterfall Start - Move address creation to implementation method
+        //InetAddress inetHost = addressCache.getIfPresent( uri.getHost() );
+        //if ( inetHost == null )
+        //{
+        //    try
+        //    {
+        //        inetHost = InetAddress.getByName( uri.getHost() );
+        //    } catch ( UnknownHostException ex )
+        //    {
+        //        callback.done( null, ex );
+        //        return;
+        //    }
+        //    addressCache.put( uri.getHost(), inetHost );
+        //}
+        // Waterfall End
 
         ChannelFutureListener future = new ChannelFutureListener()
         {
@@ -92,7 +98,42 @@ public class HttpClient
             }
         };
 
-        new Bootstrap().channel( PipelineUtils.getChannel( null ) ).group( eventLoop ).handler( new HttpInitializer( callback, ssl, uri.getHost(), port ) ).
+
+        // Waterfall Start - Optionally use Netty's async DNS Resolver
+        if (net.md_5.bungee.api.ProxyServer.getInstance().getConfig().isUseNettyDnsResolver()) {
+            getWithNettyResolver(eventLoop, uri, port, future, callback, ssl);
+        } else {
+            getWithDefaultResolver(eventLoop, uri, port, future, callback, ssl);
+        }
+        //new Bootstrap().channel( PipelineUtils.getChannel() ).group( eventLoop ).handler( new HttpInitializer( callback, ssl, uri.getHost(), port ) ).
+        //        option( ChannelOption.CONNECT_TIMEOUT_MILLIS, TIMEOUT ).remoteAddress( inetHost, port ).connect().addListener( future );
+    }
+
+    private static void getWithNettyResolver(EventLoop eventLoop, URI uri, int port, ChannelFutureListener future, Callback<String> callback, boolean ssl) {
+        java.net.InetSocketAddress address = java.net.InetSocketAddress.createUnresolved(uri.getHost(), port);
+        // Waterfall - netty reflection -> factory
+        new Bootstrap().channelFactory( PipelineUtils.getChannelFactory( null ) ).group( eventLoop ).handler( new HttpInitializer( callback, ssl, uri.getHost(), port ) ).
+                option( ChannelOption.CONNECT_TIMEOUT_MILLIS, TIMEOUT ).resolver(dnsResolverGroup).remoteAddress( address ).connect().addListener( future );
+    }
+
+    private static void getWithDefaultResolver(EventLoop eventLoop, URI uri, int port, ChannelFutureListener future, Callback<String> callback, boolean ssl) {
+        // This is identical to the Bungee implementation of #get other than the absence of the ChannelFutureListener creation
+        InetAddress inetHost = addressCache.getIfPresent( uri.getHost() );
+        if ( inetHost == null )
+        {
+            try
+            {
+                inetHost = InetAddress.getByName( uri.getHost() );
+            } catch ( UnknownHostException ex )
+            {
+                callback.done( null, ex );
+                return;
+            }
+            addressCache.put( uri.getHost(), inetHost );
+        }
+        // Waterfall - netty reflection -> factory
+        new Bootstrap().channelFactory( PipelineUtils.getChannelFactory( null ) ).group( eventLoop ).handler( new HttpInitializer( callback, ssl, uri.getHost(), port ) ).
                 option( ChannelOption.CONNECT_TIMEOUT_MILLIS, TIMEOUT ).remoteAddress( inetHost, port ).connect().addListener( future );
     }
+    // Waterfall End
 }
diff --git a/proxy/src/main/java/net/md_5/bungee/http/HttpHandler.java b/proxy/src/main/java/net/md_5/bungee/http/HttpHandler.java
index a1e59b47..e2911d5e 100644
--- a/proxy/src/main/java/net/md_5/bungee/http/HttpHandler.java
+++ b/proxy/src/main/java/net/md_5/bungee/http/HttpHandler.java
@@ -16,7 +16,7 @@ public class HttpHandler extends SimpleChannelInboundHandler<HttpObject>
 {
 
     private final Callback<String> callback;
-    private final StringBuilder buffer = new StringBuilder();
+    private final StringBuilder buffer = new StringBuilder(640);
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception
diff --git a/proxy/src/main/java/net/md_5/bungee/module/JenkinsModuleSource.java b/proxy/src/main/java/net/md_5/bungee/module/JenkinsModuleSource.java
index 064639f3..4110bdc3 100644
--- a/proxy/src/main/java/net/md_5/bungee/module/JenkinsModuleSource.java
+++ b/proxy/src/main/java/net/md_5/bungee/module/JenkinsModuleSource.java
@@ -1,10 +1,10 @@
 package net.md_5.bungee.module;
 
-import com.google.common.io.ByteStreams;
-import com.google.common.io.Files;
 import java.io.IOException;
 import java.net.URL;
 import java.net.URLConnection;
+import java.nio.file.Files;
+import java.nio.file.StandardCopyOption;
 import lombok.Data;
 import net.md_5.bungee.Util;
 import net.md_5.bungee.api.ProxyServer;
@@ -19,13 +19,21 @@ public class JenkinsModuleSource implements ModuleSource
         ProxyServer.getInstance().getLogger().info( "Attempting to Jenkins download module " + module.getName() + " v" + version.getBuild() );
         try
         {
-            URL website = new URL( "https://ci.md-5.net/job/BungeeCord/" + version.getBuild() + "/artifact/module/" + module.getName().replace( '_', '-' ) + "/target/" + module.getName() + ".jar" );
+            final String url = String.format(
+                "https://api.papermc.io/v2/projects/%1$s/versions/%2$s/builds/%3$s/downloads/%4$s-%2$s-%3$s.jar",
+                "waterfall",
+                net.md_5.bungee.api.ProxyServer.getInstance().getVersion().split(":")[2].split("-")[0],
+                version.getBuild(),
+                module.getName()
+            );
+            URL website = new URL( url );
             URLConnection con = website.openConnection();
             // 15 second timeout at various stages
             con.setConnectTimeout( 15000 );
             con.setReadTimeout( 15000 );
+            con.setRequestProperty( "User-Agent", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36" );
 
-            Files.write( ByteStreams.toByteArray( con.getInputStream() ), module.getFile() );
+            Files.copy( con.getInputStream(), module.getFile().toPath(), StandardCopyOption.REPLACE_EXISTING );
             ProxyServer.getInstance().getLogger().info( "Download complete" );
         } catch ( IOException ex )
         {
diff --git a/proxy/src/main/java/net/md_5/bungee/netty/ChannelWrapper.java b/proxy/src/main/java/net/md_5/bungee/netty/ChannelWrapper.java
index 682bb807..e0a35f73 100644
--- a/proxy/src/main/java/net/md_5/bungee/netty/ChannelWrapper.java
+++ b/proxy/src/main/java/net/md_5/bungee/netty/ChannelWrapper.java
@@ -185,7 +185,7 @@ public class ChannelWrapper
 
         if ( ch.pipeline().get( PacketDecompressor.class ) == null && compressionThreshold >= 0 )
         {
-            addBefore( PipelineUtils.PACKET_DECODER, "decompress", new PacketDecompressor() );
+            addBefore( PipelineUtils.PACKET_DECODER, "decompress", new PacketDecompressor(compressionThreshold) );
         }
         if ( compressionThreshold < 0 )
         {
diff --git a/proxy/src/main/java/net/md_5/bungee/netty/HandlerBoss.java b/proxy/src/main/java/net/md_5/bungee/netty/HandlerBoss.java
index d82173b1..a96fb58e 100644
--- a/proxy/src/main/java/net/md_5/bungee/netty/HandlerBoss.java
+++ b/proxy/src/main/java/net/md_5/bungee/netty/HandlerBoss.java
@@ -156,6 +156,14 @@ public class HandlerBoss extends ChannelInboundHandlerAdapter
                     ProxyServer.getInstance().getLogger().log( Level.WARNING, "{0} - read timed out", handler );
                 } else if ( cause instanceof DecoderException )
                 {
+                    // Waterfall start
+                    if (net.md_5.bungee.protocol.MinecraftDecoder.DEBUG) {
+                        java.util.logging.LogRecord logRecord = new java.util.logging.LogRecord(Level.WARNING, "{0} - A decoder exception has been thrown:");
+                        logRecord.setParameters(new Object[]{handler});
+                        logRecord.setThrown(cause);
+                        ProxyServer.getInstance().getLogger().log(logRecord);
+                    } else
+                    // Waterfall end
                     if ( cause instanceof CorruptedFrameException )
                     {
                         ProxyServer.getInstance().getLogger().log( Level.WARNING, "{0} - corrupted frame: {1}", new Object[]
diff --git a/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java b/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java
index 2446f489..37e37aaf 100644
--- a/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java
+++ b/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java
@@ -1,9 +1,11 @@
 package net.md_5.bungee.netty;
 
 import com.google.common.base.Preconditions;
+import io.github.waterfallmc.waterfall.event.ConnectionInitEvent;
 import io.netty.buffer.PooledByteBufAllocator;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
+import io.netty.channel.ChannelFactory;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.EventLoopGroup;
@@ -55,7 +57,7 @@ import net.md_5.bungee.protocol.Varint21LengthFieldPrepender;
 public class PipelineUtils
 {
 
-    public static final AttributeKey<ListenerInfo> LISTENER = AttributeKey.valueOf( "ListerInfo" );
+    public static final AttributeKey<ListenerInfo> LISTENER = AttributeKey.newInstance( "ListerInfo" );
     public static final ChannelInitializer<Channel> SERVER_CHILD = new ChannelInitializer<Channel>()
     {
         @Override
@@ -68,7 +70,6 @@ public class PipelineUtils
                 ch.close();
                 return;
             }
-
             ListenerInfo listener = ch.attr( LISTENER ).get();
 
             if ( BungeeCord.getInstance().getPluginManager().callEvent( new ClientConnectEvent( remoteAddress, listener ) ).isCancelled() )
@@ -77,7 +78,21 @@ public class PipelineUtils
                 return;
             }
 
+            ConnectionInitEvent connectionInitEvent = new ConnectionInitEvent(ch.remoteAddress(), listener, (result, throwable) -> { // Waterfall
+
+            if (result.isCancelled()) {
+                ch.close();
+                return;
+            }
+
+
+            try {
             BASE.initChannel( ch );
+            } catch (Exception e) {
+                e.printStackTrace();
+                ch.close();
+                return;
+            }
             ch.pipeline().addBefore( FRAME_DECODER, LEGACY_DECODER, new LegacyDecoder() );
             ch.pipeline().addAfter( FRAME_DECODER, PACKET_DECODER, new MinecraftDecoder( Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion() ) );
             ch.pipeline().addAfter( FRAME_PREPENDER, PACKET_ENCODER, new MinecraftEncoder( Protocol.HANDSHAKE, true, ProxyServer.getInstance().getProtocolVersion() ) );
@@ -88,6 +103,9 @@ public class PipelineUtils
             {
                 ch.pipeline().addFirst( new HAProxyMessageDecoder() );
             }
+            }); // Waterfall
+
+            BungeeCord.getInstance().getPluginManager().callEvent(connectionInitEvent);
         }
     };
     public static final Base BASE = new Base( false );
@@ -107,6 +125,12 @@ public class PipelineUtils
 
     private static boolean epoll;
     private static boolean io_uring;
+    // Waterfall start: netty reflection -> factory
+    private static final ChannelFactory<? extends ServerChannel> serverChannelFactory;
+    private static final ChannelFactory<? extends ServerChannel> serverChannelDomainFactory;
+    private static final ChannelFactory<? extends Channel> channelFactory;
+    private static final ChannelFactory<? extends Channel> channelDomainFactory;
+    // Waterfall end
 
     static
     {
@@ -137,6 +161,12 @@ public class PipelineUtils
                 }
             }
         }
+        // Waterfall start: netty reflection -> factory
+        serverChannelFactory = io_uring ? IOUringServerSocketChannel::new : epoll ? EpollServerSocketChannel::new : NioServerSocketChannel::new;
+        serverChannelDomainFactory = io_uring ? IOUringServerSocketChannel::new : epoll ? EpollServerDomainSocketChannel::new : null;
+        channelFactory = io_uring ? IOUringSocketChannel::new : epoll ? EpollSocketChannel::new : NioSocketChannel::new;
+        channelDomainFactory = io_uring ? IOUringSocketChannel::new : epoll ? EpollDomainSocketChannel::new : null;
+        // Waterfall end
     }
 
     public static EventLoopGroup newEventLoopGroup(int threads, ThreadFactory factory)
@@ -168,6 +198,34 @@ public class PipelineUtils
         return io_uring ? IOUringSocketChannel.class : epoll ? EpollSocketChannel.class : NioSocketChannel.class;
     }
 
+    // Waterfall start: netty reflection -> factory
+    public static ChannelFactory<? extends ServerChannel> getServerChannelFactory(SocketAddress address)
+    {
+        if ( address instanceof DomainSocketAddress )
+        {
+            ChannelFactory<? extends ServerChannel> factory = PipelineUtils.serverChannelDomainFactory;
+            Preconditions.checkState( factory != null, "Epoll required to have UNIX sockets" );
+
+            return factory;
+        }
+
+        return serverChannelFactory;
+    }
+
+    public static ChannelFactory<? extends Channel> getChannelFactory(SocketAddress address)
+    {
+        if ( address instanceof DomainSocketAddress )
+        {
+            ChannelFactory<? extends Channel> factory = PipelineUtils.channelDomainFactory;
+            Preconditions.checkState( factory != null, "Epoll required to have UNIX sockets" );
+
+            return factory;
+        }
+
+        return channelFactory;
+    }
+    // Waterfall end
+
     public static Class<? extends DatagramChannel> getDatagramChannel()
     {
         return io_uring ? IOUringDatagramChannel.class : epoll ? EpollDatagramChannel.class : NioDatagramChannel.class;
@@ -194,6 +252,7 @@ public class PipelineUtils
             {
                 // IP_TOS is not supported (Windows XP / Windows Server 2003)
             }
+            ch.config().setOption( ChannelOption.TCP_NODELAY, true );
             ch.config().setAllocator( PooledByteBufAllocator.DEFAULT );
             ch.config().setWriteBufferWaterMark( MARK );
 
diff --git a/proxy/src/main/java/net/md_5/bungee/scheduler/BungeeTask.java b/proxy/src/main/java/net/md_5/bungee/scheduler/BungeeTask.java
index 38b75b51..02ec98fc 100644
--- a/proxy/src/main/java/net/md_5/bungee/scheduler/BungeeTask.java
+++ b/proxy/src/main/java/net/md_5/bungee/scheduler/BungeeTask.java
@@ -3,6 +3,9 @@ package net.md_5.bungee.scheduler;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.logging.Level;
+
+import io.github.waterfallmc.waterfall.event.ProxyExceptionEvent;
+import io.github.waterfallmc.waterfall.exception.ProxySchedulerException;
 import lombok.Data;
 import net.md_5.bungee.api.ProxyServer;
 import net.md_5.bungee.api.plugin.Plugin;
@@ -63,7 +66,11 @@ public class BungeeTask implements Runnable, ScheduledTask
                 task.run();
             } catch ( Throwable t )
             {
-                ProxyServer.getInstance().getLogger().log( Level.SEVERE, "Task " + this + " encountered an exception", t );
+                //Waterfall start - throw exception event
+                String msg = String.format( "Task %s encountered an exception", this );
+                ProxyServer.getInstance().getLogger().log( Level.SEVERE, msg, t );
+                ProxyServer.getInstance().getPluginManager().callEvent( new ProxyExceptionEvent( new ProxySchedulerException( msg, t, this ) ) );
+                //Waterfall end
             }
 
             // If we have a period of 0 or less, only run once
diff --git a/proxy/src/main/resources/messages.properties b/proxy/src/main/resources/messages.properties
index 149c742f..8d5075f6 100644
--- a/proxy/src/main/resources/messages.properties
+++ b/proxy/src/main/resources/messages.properties
@@ -25,6 +25,7 @@ offline_mode_player=\u00a7cNot authenticated with Minecraft.net
 secure_profile_required=\u00a7cA secure profile is required to join this server.
 secure_profile_expired=\u00a7cSecure profile expired.
 secure_profile_invalid=\u00a7cSecure profile invalid.
+secure_profile_unsupported=\u00a7cOutdated client, secure profile not supported. Please use 1.19 or newer.
 message_needed=\u00a7cYou must supply a message.
 error_occurred_player=\u00a7cAn error occurred while parsing your message. (Hover for details)
 error_occurred_console=\u00a7cAn error occurred while parsing your message: {0}
diff --git a/query/pom.xml b/query/pom.xml
index 84c5f207..5e1b0ac7 100644
--- a/query/pom.xml
+++ b/query/pom.xml
@@ -4,19 +4,19 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-parent</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-parent</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-query</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-query</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
-    <name>BungeeCord-Query</name>
-    <description>Minecraft query implementation based on the BungeeCord API.</description>
+    <name>Waterfall-Query</name>
+    <description>Minecraft query implementation based on the Waterfall API.</description>
 
     <dependencies>
         <dependency>
@@ -25,8 +25,8 @@
             <scope>compile</scope>
         </dependency>
         <dependency>
-            <groupId>net.md-5</groupId>
-            <artifactId>bungeecord-api</artifactId>
+            <groupId>io.github.waterfallmc</groupId>
+            <artifactId>waterfall-api</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
diff --git a/query/src/main/java/net/md_5/bungee/query/QueryHandler.java b/query/src/main/java/net/md_5/bungee/query/QueryHandler.java
index 9b81197f..0c1ecfb8 100644
--- a/query/src/main/java/net/md_5/bungee/query/QueryHandler.java
+++ b/query/src/main/java/net/md_5/bungee/query/QueryHandler.java
@@ -2,6 +2,8 @@ package net.md_5.bungee.query;
 
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
+import io.github.waterfallmc.waterfall.QueryResult;
+import io.github.waterfallmc.waterfall.event.ProxyQueryEvent;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.AddressedEnvelope;
 import io.netty.channel.ChannelHandlerContext;
@@ -9,10 +11,12 @@ import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.DatagramPacket;
 import java.net.InetAddress;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Random;
 import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
+import java.util.stream.Collectors;
 import lombok.Data;
 import lombok.RequiredArgsConstructor;
 import net.md_5.bungee.api.ProxyServer;
@@ -28,6 +32,7 @@ public class QueryHandler extends SimpleChannelInboundHandler<DatagramPacket>
     /*========================================================================*/
     private final Random random = new Random();
     private final Cache<InetAddress, QuerySession> sessions = CacheBuilder.newBuilder().expireAfterWrite( 30, TimeUnit.SECONDS ).build();
+    private static io.github.waterfallmc.waterfall.utils.FastException cachedNoSessionException = new io.github.waterfallmc.waterfall.utils.FastException("No Session!");
 
     private void writeShort(ByteBuf buf, int s)
     {
@@ -92,22 +97,33 @@ public class QueryHandler extends SimpleChannelInboundHandler<DatagramPacket>
             QuerySession session = sessions.getIfPresent( msg.sender().getAddress() );
             if ( session == null || session.getToken() != challengeToken )
             {
-                throw new IllegalStateException( "No session!" );
+                throw cachedNoSessionException; // Waterfall
             }
 
+            // Waterfall start
+            List<String> players = bungee.getPlayers().stream().map(ProxiedPlayer::getName).collect(Collectors.toList());
+
+            ProxyQueryEvent event = new ProxyQueryEvent(listener, new QueryResult(listener.getMotd(), "SMP", "Waterfall_Proxy",
+                    bungee.getOnlineCount(), listener.getMaxPlayers(), listener.getHost().getPort(),
+                    listener.getHost().getHostString(), "MINECRAFT",  players, bungee.getGameVersion()));
+            QueryResult result = bungee.getPluginManager().callEvent(event).getResult();
+            // Waterfall end
+
             out.writeByte( 0x00 );
             out.writeInt( sessionId );
 
             if ( in.readableBytes() == 0 )
             {
                 // Short response
-                writeString( out, listener.getMotd() ); // MOTD
-                writeString( out, "SMP" ); // Game Type
-                writeString( out, "BungeeCord_Proxy" ); // World Name
-                writeNumber( out, bungee.getOnlineCount() ); // Online Count
-                writeNumber( out, listener.getMaxPlayers() ); // Max Players
-                writeShort( out, listener.getHost().getPort() ); // Port
-                writeString( out, listener.getHost().getHostString() ); // IP
+                // Waterfall start
+                writeString( out, result.getMotd() ); // MOTD
+                writeString( out, result.getGameType() ); // Game Type
+                writeString( out, result.getWorldName() ); // World Name
+                writeNumber( out, result.getOnlinePlayers() ); // Online Count
+                writeNumber( out, result.getMaxPlayers() ); // Max Players
+                writeShort( out, result.getPort() ); // Port
+                writeString( out, result.getAddress() ); // IP
+                // Waterfall end
             } else if ( in.readableBytes() == 4 )
             {
                 // Long Response
@@ -117,18 +133,20 @@ public class QueryHandler extends SimpleChannelInboundHandler<DatagramPacket>
                 } );
                 Map<String, String> data = new LinkedHashMap<>();
 
-                data.put( "hostname", listener.getMotd() );
-                data.put( "gametype", "SMP" );
+                // Waterfall start
+                data.put( "hostname", result.getMotd() );
+                data.put( "gametype", result.getGameType() );
                 // Start Extra Info
-                data.put( "game_id", "MINECRAFT" );
-                data.put( "version", bungee.getGameVersion() );
-                data.put( "plugins", "" );
+                data.put( "game_id", result.getGameId() );
+                data.put( "version", result.getVersion() );
+                data.put( "plugins", "" ); // TODO: Allow population?
                 // End Extra Info
-                data.put( "map", "BungeeCord_Proxy" );
-                data.put( "numplayers", Integer.toString( bungee.getOnlineCount() ) );
-                data.put( "maxplayers", Integer.toString( listener.getMaxPlayers() ) );
-                data.put( "hostport", Integer.toString( listener.getHost().getPort() ) );
-                data.put( "hostip", listener.getHost().getHostString() );
+                data.put( "map", result.getWorldName() );
+                data.put( "numplayers", Integer.toString( result.getOnlinePlayers() ) );
+                data.put( "maxplayers", Integer.toString( result.getMaxPlayers() ) );
+                data.put( "hostport", Integer.toString( result.getPort() ) );
+                data.put( "hostip", result.getAddress() );
+                // Waterfall end
 
                 for ( Map.Entry<String, String> entry : data.entrySet() )
                 {
@@ -140,10 +158,7 @@ public class QueryHandler extends SimpleChannelInboundHandler<DatagramPacket>
                 // Padding
                 writeString( out, "\01player_\00" );
                 // Player List
-                for ( ProxiedPlayer p : bungee.getPlayers() )
-                {
-                    writeString( out, p.getName() );
-                }
+                result.getPlayers().stream().forEach(p -> writeString(out, p)); // Waterfall
                 out.writeByte( 0x00 ); // Null
             } else
             {
diff --git a/slf4j/nb-configuration.xml b/slf4j/nb-configuration.xml
deleted file mode 100644
index 7e465924..00000000
--- a/slf4j/nb-configuration.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project-shared-configuration>
-    <!--
-    This file contains additional configuration written by modules in the NetBeans IDE.
-    The configuration is intended to be shared among all the users of project and
-    therefore it is assumed to be part of version control checkout.
-    Without this configuration present, some functionality in the IDE may be limited or fail altogether.
-    -->
-    <properties xmlns="http://www.netbeans.org/ns/maven-properties-data/1">
-        <!--
-        Properties that influence various parts of the IDE, especially code formatting and the like. 
-        You can copy and paste the single properties, into the pom.xml file and the IDE will pick them up.
-        That way multiple projects can share the same settings (useful for formatting rules for example).
-        Any value defined here will override the pom.xml file value but is only applicable to the current project.
-        -->
-        <org-netbeans-modules-editor-indent.CodeStyle.usedProfile>project</org-netbeans-modules-editor-indent.CodeStyle.usedProfile>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.classDeclBracePlacement>NEW_LINE</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.classDeclBracePlacement>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.otherBracePlacement>NEW_LINE</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.otherBracePlacement>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.methodDeclBracePlacement>NEW_LINE</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.methodDeclBracePlacement>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinMethodCallParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinMethodCallParens>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinSwitchParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinSwitchParens>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinCatchParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinCatchParens>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinTryParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinTryParens>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinSynchronizedParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinSynchronizedParens>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinArrayInitBrackets>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinArrayInitBrackets>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinParens>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinWhileParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinWhileParens>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinIfParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinIfParens>
-        <org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinForParens>true</org-netbeans-modules-editor-indent.text.x-java.CodeStyle.project.spaceWithinForParens>
-    </properties>
-</project-shared-configuration>
diff --git a/slf4j/pom.xml b/slf4j/pom.xml
index 5c611d8c..8860998c 100644
--- a/slf4j/pom.xml
+++ b/slf4j/pom.xml
@@ -4,18 +4,18 @@
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>net.md-5</groupId>
-        <artifactId>bungeecord-parent</artifactId>
+        <groupId>io.github.waterfallmc</groupId>
+        <artifactId>waterfall-parent</artifactId>
         <version>1.21-R0.1-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
-    <groupId>net.md-5</groupId>
-    <artifactId>bungeecord-slf4j</artifactId>
+    <groupId>io.github.waterfallmc</groupId>
+    <artifactId>waterfall-slf4j</artifactId>
     <version>1.21-R0.1-SNAPSHOT</version>
     <packaging>jar</packaging>
 
-    <name>BungeeCord-SLF4J</name>
+    <name>Waterfall-SLF4J</name>
     <description>Wrapper over SLF4J for BungeeCord purposes.</description>
 
     <properties>
diff --git a/slf4j/src/main/java/org/slf4j/impl/JDK14LoggerAdapter.java b/slf4j/src/main/java/org/slf4j/impl/JDK14LoggerAdapter.java
deleted file mode 100644
index 49589454..00000000
--- a/slf4j/src/main/java/org/slf4j/impl/JDK14LoggerAdapter.java
+++ /dev/null
@@ -1,700 +0,0 @@
-/**
- * Copyright (c) 2004-2011 QOS.ch
- * All rights reserved.
- *
- * Permission is hereby granted, free  of charge, to any person obtaining
- * a  copy  of this  software  and  associated  documentation files  (the
- * "Software"), to  deal in  the Software without  restriction, including
- * without limitation  the rights to  use, copy, modify,  merge, publish,
- * distribute,  sublicense, and/or sell  copies of  the Software,  and to
- * permit persons to whom the Software  is furnished to do so, subject to
- * the following conditions:
- *
- * The  above  copyright  notice  and  this permission  notice  shall  be
- * included in all copies or substantial portions of the Software.
- *
- * THE  SOFTWARE IS  PROVIDED  "AS  IS", WITHOUT  WARRANTY  OF ANY  KIND,
- * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF
- * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-package org.slf4j.impl;
-
-import java.util.logging.Level;
-import java.util.logging.LogRecord;
-
-import org.slf4j.Logger;
-import org.slf4j.Marker;
-import org.slf4j.event.EventConstants;
-import org.slf4j.event.LoggingEvent;
-import org.slf4j.helpers.FormattingTuple;
-import org.slf4j.helpers.MarkerIgnoringBase;
-import org.slf4j.helpers.MessageFormatter;
-import org.slf4j.spi.LocationAwareLogger;
-
-/**
- * A wrapper over {@link java.util.logging.Logger java.util.logging.Logger} in
- * conformity with the {@link Logger} interface. Note that the logging levels
- * mentioned in this class refer to those defined in the java.util.logging
- * package.
- * 
- * @author Ceki G&uuml;lc&uuml;
- * @author Peter Royal
- */
-public final class JDK14LoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger {
-
-    private static final long serialVersionUID = -8053026990503422791L;
-
-    transient final java.util.logging.Logger logger;
-
-    // WARN: JDK14LoggerAdapter constructor should have only package access so
-    // that only JDK14LoggerFactory be able to create one.
-    JDK14LoggerAdapter(java.util.logging.Logger logger) {
-        this.logger = logger;
-        this.name = logger.getName();
-    }
-
-    /**
-     * Is this logger instance enabled for the FINEST level?
-     * 
-     * @return True if this Logger is enabled for level FINEST, false otherwise.
-     */
-    public boolean isTraceEnabled() {
-        return logger.isLoggable(Level.FINEST);
-    }
-
-    /**
-     * Log a message object at level FINEST.
-     * 
-     * @param msg
-     *          - the message object to be logged
-     */
-    public void trace(String msg) {
-        if (logger.isLoggable(Level.FINEST)) {
-            log(SELF, Level.FINEST, msg, null);
-        }
-    }
-
-    /**
-     * Log a message at level FINEST according to the specified format and
-     * argument.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for level FINEST.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param arg
-     *          the argument
-     */
-    public void trace(String format, Object arg) {
-        if (logger.isLoggable(Level.FINEST)) {
-            FormattingTuple ft = MessageFormatter.format(format, arg);
-            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log a message at level FINEST according to the specified format and
-     * arguments.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for the FINEST level.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param arg1
-     *          the first argument
-     * @param arg2
-     *          the second argument
-     */
-    public void trace(String format, Object arg1, Object arg2) {
-        if (logger.isLoggable(Level.FINEST)) {
-            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);
-            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log a message at level FINEST according to the specified format and
-     * arguments.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for the FINEST level.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param argArray
-     *          an array of arguments
-     */
-    public void trace(String format, Object... argArray) {
-        if (logger.isLoggable(Level.FINEST)) {
-            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);
-            log(SELF, Level.FINEST, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log an exception (throwable) at level FINEST with an accompanying message.
-     * 
-     * @param msg
-     *          the message accompanying the exception
-     * @param t
-     *          the exception (throwable) to log
-     */
-    public void trace(String msg, Throwable t) {
-        if (logger.isLoggable(Level.FINEST)) {
-            log(SELF, Level.FINEST, msg, t);
-        }
-    }
-
-    /**
-     * Is this logger instance enabled for the FINE level?
-     * 
-     * @return True if this Logger is enabled for level FINE, false otherwise.
-     */
-    public boolean isDebugEnabled() {
-        return logger.isLoggable(Level.FINE);
-    }
-
-    /**
-     * Log a message object at level FINE.
-     * 
-     * @param msg
-     *          - the message object to be logged
-     */
-    public void debug(String msg) {
-        if (logger.isLoggable(Level.FINE)) {
-            log(SELF, Level.FINE, msg, null);
-        }
-    }
-
-    /**
-     * Log a message at level FINE according to the specified format and argument.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for level FINE.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param arg
-     *          the argument
-     */
-    public void debug(String format, Object arg) {
-        if (logger.isLoggable(Level.FINE)) {
-            FormattingTuple ft = MessageFormatter.format(format, arg);
-            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log a message at level FINE according to the specified format and
-     * arguments.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for the FINE level.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param arg1
-     *          the first argument
-     * @param arg2
-     *          the second argument
-     */
-    public void debug(String format, Object arg1, Object arg2) {
-        if (logger.isLoggable(Level.FINE)) {
-            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);
-            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log a message at level FINE according to the specified format and
-     * arguments.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for the FINE level.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param argArray
-     *          an array of arguments
-     */
-    public void debug(String format, Object... argArray) {
-        if (logger.isLoggable(Level.FINE)) {
-            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);
-            log(SELF, Level.FINE, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log an exception (throwable) at level FINE with an accompanying message.
-     * 
-     * @param msg
-     *          the message accompanying the exception
-     * @param t
-     *          the exception (throwable) to log
-     */
-    public void debug(String msg, Throwable t) {
-        if (logger.isLoggable(Level.FINE)) {
-            log(SELF, Level.FINE, msg, t);
-        }
-    }
-
-    /**
-     * Is this logger instance enabled for the INFO level?
-     * 
-     * @return True if this Logger is enabled for the INFO level, false otherwise.
-     */
-    public boolean isInfoEnabled() {
-        return logger.isLoggable(Level.INFO);
-    }
-
-    /**
-     * Log a message object at the INFO level.
-     * 
-     * @param msg
-     *          - the message object to be logged
-     */
-    public void info(String msg) {
-        if (logger.isLoggable(Level.INFO)) {
-            log(SELF, Level.INFO, msg, null);
-        }
-    }
-
-    /**
-     * Log a message at level INFO according to the specified format and argument.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for the INFO level.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param arg
-     *          the argument
-     */
-    public void info(String format, Object arg) {
-        if (logger.isLoggable(Level.INFO)) {
-            FormattingTuple ft = MessageFormatter.format(format, arg);
-            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log a message at the INFO level according to the specified format and
-     * arguments.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for the INFO level.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param arg1
-     *          the first argument
-     * @param arg2
-     *          the second argument
-     */
-    public void info(String format, Object arg1, Object arg2) {
-        if (logger.isLoggable(Level.INFO)) {
-            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);
-            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log a message at level INFO according to the specified format and
-     * arguments.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for the INFO level.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param argArray
-     *          an array of arguments
-     */
-    public void info(String format, Object... argArray) {
-        if (logger.isLoggable(Level.INFO)) {
-            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);
-            log(SELF, Level.INFO, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log an exception (throwable) at the INFO level with an accompanying
-     * message.
-     * 
-     * @param msg
-     *          the message accompanying the exception
-     * @param t
-     *          the exception (throwable) to log
-     */
-    public void info(String msg, Throwable t) {
-        if (logger.isLoggable(Level.INFO)) {
-            log(SELF, Level.INFO, msg, t);
-        }
-    }
-
-    /**
-     * Is this logger instance enabled for the WARNING level?
-     * 
-     * @return True if this Logger is enabled for the WARNING level, false
-     *         otherwise.
-     */
-    public boolean isWarnEnabled() {
-        return logger.isLoggable(Level.WARNING);
-    }
-
-    /**
-     * Log a message object at the WARNING level.
-     * 
-     * @param msg
-     *          - the message object to be logged
-     */
-    public void warn(String msg) {
-        if (logger.isLoggable(Level.WARNING)) {
-            log(SELF, Level.WARNING, msg, null);
-        }
-    }
-
-    /**
-     * Log a message at the WARNING level according to the specified format and
-     * argument.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for the WARNING level.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param arg
-     *          the argument
-     */
-    public void warn(String format, Object arg) {
-        if (logger.isLoggable(Level.WARNING)) {
-            FormattingTuple ft = MessageFormatter.format(format, arg);
-            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log a message at the WARNING level according to the specified format and
-     * arguments.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for the WARNING level.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param arg1
-     *          the first argument
-     * @param arg2
-     *          the second argument
-     */
-    public void warn(String format, Object arg1, Object arg2) {
-        if (logger.isLoggable(Level.WARNING)) {
-            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);
-            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log a message at level WARNING according to the specified format and
-     * arguments.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for the WARNING level.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param argArray
-     *          an array of arguments
-     */
-    public void warn(String format, Object... argArray) {
-        if (logger.isLoggable(Level.WARNING)) {
-            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);
-            log(SELF, Level.WARNING, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log an exception (throwable) at the WARNING level with an accompanying
-     * message.
-     * 
-     * @param msg
-     *          the message accompanying the exception
-     * @param t
-     *          the exception (throwable) to log
-     */
-    public void warn(String msg, Throwable t) {
-        if (logger.isLoggable(Level.WARNING)) {
-            log(SELF, Level.WARNING, msg, t);
-        }
-    }
-
-    /**
-     * Is this logger instance enabled for level SEVERE?
-     * 
-     * @return True if this Logger is enabled for level SEVERE, false otherwise.
-     */
-    public boolean isErrorEnabled() {
-        return logger.isLoggable(Level.SEVERE);
-    }
-
-    /**
-     * Log a message object at the SEVERE level.
-     * 
-     * @param msg
-     *          - the message object to be logged
-     */
-    public void error(String msg) {
-        if (logger.isLoggable(Level.SEVERE)) {
-            log(SELF, Level.SEVERE, msg, null);
-        }
-    }
-
-    /**
-     * Log a message at the SEVERE level according to the specified format and
-     * argument.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for the SEVERE level.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param arg
-     *          the argument
-     */
-    public void error(String format, Object arg) {
-        if (logger.isLoggable(Level.SEVERE)) {
-            FormattingTuple ft = MessageFormatter.format(format, arg);
-            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log a message at the SEVERE level according to the specified format and
-     * arguments.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for the SEVERE level.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param arg1
-     *          the first argument
-     * @param arg2
-     *          the second argument
-     */
-    public void error(String format, Object arg1, Object arg2) {
-        if (logger.isLoggable(Level.SEVERE)) {
-            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);
-            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log a message at level SEVERE according to the specified format and
-     * arguments.
-     * 
-     * <p>
-     * This form avoids superfluous object creation when the logger is disabled
-     * for the SEVERE level.
-     * </p>
-     * 
-     * @param format
-     *          the format string
-     * @param arguments
-     *          an array of arguments
-     */
-    public void error(String format, Object... arguments) {
-        if (logger.isLoggable(Level.SEVERE)) {
-            FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);
-            log(SELF, Level.SEVERE, ft.getMessage(), ft.getThrowable());
-        }
-    }
-
-    /**
-     * Log an exception (throwable) at the SEVERE level with an accompanying
-     * message.
-     * 
-     * @param msg
-     *          the message accompanying the exception
-     * @param t
-     *          the exception (throwable) to log
-     */
-    public void error(String msg, Throwable t) {
-        if (logger.isLoggable(Level.SEVERE)) {
-            log(SELF, Level.SEVERE, msg, t);
-        }
-    }
-
-    /**
-     * Log the message at the specified level with the specified throwable if any.
-     * This method creates a LogRecord and fills in caller date before calling
-     * this instance's JDK14 logger.
-     * 
-     * See bug report #13 for more details.
-     * 
-     * @param level
-     * @param msg
-     * @param t
-     */
-    private void log(String callerFQCN, Level level, String msg, Throwable t) {
-        // millis and thread are filled by the constructor
-        LogRecord record = new LogRecord(level, msg);
-        record.setLoggerName(getName());
-        record.setThrown(t);
-        // Note: parameters in record are not set because SLF4J only
-        // supports a single formatting style
-        fillCallerData(callerFQCN, record);
-        logger.log(record);
-    }
-
-    static String SELF = JDK14LoggerAdapter.class.getName();
-    static String SUPER = MarkerIgnoringBase.class.getName();
-
-    private static final boolean FILL_CALLER_DATA = Boolean.getBoolean( "net.md_5.bungee.slf4j-caller-data" );
-
-    /**
-     * Fill in caller data if possible.
-     * 
-     * @param record
-     *          The record to update
-     */
-    final private void fillCallerData(String callerFQCN, LogRecord record) {
-        if ( !FILL_CALLER_DATA )
-        {
-            return;
-        }
-        StackTraceElement[] steArray = new Throwable().getStackTrace();
-
-        int selfIndex = -1;
-        for (int i = 0; i < steArray.length; i++) {
-            final String className = steArray[i].getClassName();
-            if (className.equals(callerFQCN) || className.equals(SUPER)) {
-                selfIndex = i;
-                break;
-            }
-        }
-
-        int found = -1;
-        for (int i = selfIndex + 1; i < steArray.length; i++) {
-            final String className = steArray[i].getClassName();
-            if (!(className.equals(callerFQCN) || className.equals(SUPER))) {
-                found = i;
-                break;
-            }
-        }
-
-        if (found != -1) {
-            StackTraceElement ste = steArray[found];
-            // setting the class name has the side effect of setting
-            // the needToInferCaller variable to false.
-            record.setSourceClassName(ste.getClassName());
-            record.setSourceMethodName(ste.getMethodName());
-        }
-    }
-
-    public void log(Marker marker, String callerFQCN, int level, String message, Object[] argArray, Throwable t) {
-        Level julLevel = slf4jLevelIntToJULLevel(level);
-        // the logger.isLoggable check avoids the unconditional
-        // construction of location data for disabled log
-        // statements. As of 2008-07-31, callers of this method
-        // do not perform this check. See also
-        // http://jira.qos.ch/browse/SLF4J-81
-        if (logger.isLoggable(julLevel)) {
-            log(callerFQCN, julLevel, message, t);
-        }
-    }
-
-    private Level slf4jLevelIntToJULLevel(int slf4jLevelInt) {
-        Level julLevel;
-        switch (slf4jLevelInt) {
-        case LocationAwareLogger.TRACE_INT:
-            julLevel = Level.FINEST;
-            break;
-        case LocationAwareLogger.DEBUG_INT:
-            julLevel = Level.FINE;
-            break;
-        case LocationAwareLogger.INFO_INT:
-            julLevel = Level.INFO;
-            break;
-        case LocationAwareLogger.WARN_INT:
-            julLevel = Level.WARNING;
-            break;
-        case LocationAwareLogger.ERROR_INT:
-            julLevel = Level.SEVERE;
-            break;
-        default:
-            throw new IllegalStateException("Level number " + slf4jLevelInt + " is not recognized.");
-        }
-        return julLevel;
-    }
-
-    /**
-     * @since 1.7.15
-     */
-    public void log(LoggingEvent event) {
-        Level julLevel = slf4jLevelIntToJULLevel(event.getLevel().toInt());
-        if (logger.isLoggable(julLevel)) {
-            LogRecord record = eventToRecord(event, julLevel);
-            logger.log(record);
-        }
-    }
-
-    private LogRecord eventToRecord(LoggingEvent event, Level julLevel) {
-        String format = event.getMessage();
-        Object[] arguments = event.getArgumentArray();
-        FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);
-        if (ft.getThrowable() != null && event.getThrowable() != null) {
-            throw new IllegalArgumentException("both last element in argument array and last argument are of type Throwable");
-        }
-
-        Throwable t = event.getThrowable();
-        if (ft.getThrowable() != null) {
-            t = ft.getThrowable();
-            throw new IllegalStateException("fix above code");
-        }
-
-        LogRecord record = new LogRecord(julLevel, ft.getMessage());
-        record.setLoggerName(event.getLoggerName());
-        record.setMillis(event.getTimeStamp());
-        record.setSourceClassName(EventConstants.NA_SUBST);
-        record.setSourceMethodName(EventConstants.NA_SUBST);
-
-        record.setThrown(t);
-        return record;
-    }
-}
diff --git a/slf4j/src/main/java/org/slf4j/impl/JDK14LoggerFactory.java b/slf4j/src/main/java/org/slf4j/impl/JDK14LoggerFactory.java
deleted file mode 100644
index 2d6eaaf8..00000000
--- a/slf4j/src/main/java/org/slf4j/impl/JDK14LoggerFactory.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/**
- * Copyright (c) 2004-2011 QOS.ch
- * All rights reserved.
- *
- * Permission is hereby granted, free  of charge, to any person obtaining
- * a  copy  of this  software  and  associated  documentation files  (the
- * "Software"), to  deal in  the Software without  restriction, including
- * without limitation  the rights to  use, copy, modify,  merge, publish,
- * distribute,  sublicense, and/or sell  copies of  the Software,  and to
- * permit persons to whom the Software  is furnished to do so, subject to
- * the following conditions:
- *
- * The  above  copyright  notice  and  this permission  notice  shall  be
- * included in all copies or substantial portions of the Software.
- *
- * THE  SOFTWARE IS  PROVIDED  "AS  IS", WITHOUT  WARRANTY  OF ANY  KIND,
- * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF
- * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-package org.slf4j.impl;
-
-import org.slf4j.Logger;
-import org.slf4j.ILoggerFactory;
-
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-
-/**
- * JDK14LoggerFactory is an implementation of {@link ILoggerFactory} returning
- * the appropriately named {@link JDK14LoggerAdapter} instance.
- * 
- * @author Ceki G&uuml;lc&uuml;
- */
-public class JDK14LoggerFactory implements ILoggerFactory {
-
-    // key: name (String), value: a JDK14LoggerAdapter;
-    ConcurrentMap<String, Logger> loggerMap;
-    public static java.util.logging.Logger LOGGER; // BungeeCord
-
-    public JDK14LoggerFactory() {
-        loggerMap = new ConcurrentHashMap<String, Logger>();
-        // ensure jul initialization. see SLF4J-359 
-        // note that call to java.util.logging.LogManager.getLogManager() fails on the Google App Engine platform. See SLF4J-363
-        java.util.logging.Logger.getLogger("");
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see org.slf4j.ILoggerFactory#getLogger(java.lang.String)
-     */
-    public Logger getLogger(String name) {
-        // the root logger is called "" in JUL
-        if (name.equalsIgnoreCase(Logger.ROOT_LOGGER_NAME)) {
-            name = "";
-        }
-
-        Logger slf4jLogger = loggerMap.get(name);
-        if (slf4jLogger != null)
-            return slf4jLogger;
-        else {
-            java.util.logging.Logger julLogger = LOGGER; // BungeeCord - TODO: per-plugin loggers
-            Logger newInstance = new JDK14LoggerAdapter(julLogger);
-            Logger oldInstance = loggerMap.putIfAbsent(name, newInstance);
-            return oldInstance == null ? newInstance : oldInstance;
-        }
-    }
-}
diff --git a/slf4j/src/main/java/org/slf4j/impl/StaticLoggerBinder.java b/slf4j/src/main/java/org/slf4j/impl/StaticLoggerBinder.java
deleted file mode 100644
index ebf8ae11..00000000
--- a/slf4j/src/main/java/org/slf4j/impl/StaticLoggerBinder.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/**
- * Copyright (c) 2004-2011 QOS.ch
- * All rights reserved.
- *
- * Permission is hereby granted, free  of charge, to any person obtaining
- * a  copy  of this  software  and  associated  documentation files  (the
- * "Software"), to  deal in  the Software without  restriction, including
- * without limitation  the rights to  use, copy, modify,  merge, publish,
- * distribute,  sublicense, and/or sell  copies of  the Software,  and to
- * permit persons to whom the Software  is furnished to do so, subject to
- * the following conditions:
- *
- * The  above  copyright  notice  and  this permission  notice  shall  be
- * included in all copies or substantial portions of the Software.
- *
- * THE  SOFTWARE IS  PROVIDED  "AS  IS", WITHOUT  WARRANTY  OF ANY  KIND,
- * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF
- * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-package org.slf4j.impl;
-
-import org.slf4j.ILoggerFactory;
-import org.slf4j.LoggerFactory;
-import org.slf4j.spi.LoggerFactoryBinder;
-
-/**
- * The binding of {@link LoggerFactory} class with an actual instance of 
- * {@link ILoggerFactory} is performed using information returned by this class. 
- * 
- * @author Ceki G&uuml;lc&uuml;
- */
-public class StaticLoggerBinder implements LoggerFactoryBinder {
-
-    /**
-     * The unique instance of this class.
-     * 
-     */
-    private static final StaticLoggerBinder SINGLETON = new StaticLoggerBinder();
-
-    /**
-     * Return the singleton of this class.
-     * 
-     * @return the StaticLoggerBinder singleton
-     */
-    public static final StaticLoggerBinder getSingleton() {
-        return SINGLETON;
-    }
-
-    /**
-     * Declare the version of the SLF4J API this implementation is compiled against. 
-     * The value of this field is modified with each major release. 
-     */
-    // to avoid constant folding by the compiler, this field must *not* be final
-    public static String REQUESTED_API_VERSION = "1.6.99"; // !final
-
-    private static final String loggerFactoryClassStr = org.slf4j.impl.JDK14LoggerFactory.class.getName();
-
-    /** The ILoggerFactory instance returned by the {@link #getLoggerFactory} method
-     * should always be the same object
-     */
-    private final ILoggerFactory loggerFactory;
-
-    private StaticLoggerBinder() {
-        // Note: JCL gets substituted at build time by an appropriate Ant task
-        loggerFactory = new org.slf4j.impl.JDK14LoggerFactory();
-    }
-
-    public ILoggerFactory getLoggerFactory() {
-        return loggerFactory;
-    }
-
-    public String getLoggerFactoryClassStr() {
-        return loggerFactoryClassStr;
-    }
-}
diff --git a/slf4j/src/main/java/org/slf4j/impl/StaticMDCBinder.java b/slf4j/src/main/java/org/slf4j/impl/StaticMDCBinder.java
deleted file mode 100644
index 0a1dcb4c..00000000
--- a/slf4j/src/main/java/org/slf4j/impl/StaticMDCBinder.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/**
- * Copyright (c) 2004-2011 QOS.ch
- * All rights reserved.
- *
- * Permission is hereby granted, free  of charge, to any person obtaining
- * a  copy  of this  software  and  associated  documentation files  (the
- * "Software"), to  deal in  the Software without  restriction, including
- * without limitation  the rights to  use, copy, modify,  merge, publish,
- * distribute,  sublicense, and/or sell  copies of  the Software,  and to
- * permit persons to whom the Software  is furnished to do so, subject to
- * the following conditions:
- *
- * The  above  copyright  notice  and  this permission  notice  shall  be
- * included in all copies or substantial portions of the Software.
- *
- * THE  SOFTWARE IS  PROVIDED  "AS  IS", WITHOUT  WARRANTY  OF ANY  KIND,
- * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF
- * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-package org.slf4j.impl;
-
-import org.slf4j.helpers.BasicMDCAdapter;
-import org.slf4j.spi.MDCAdapter;
-
-/**
- * This implementation is bound to {@link BasicMDCAdapter}.
- *
- * @author Ceki G&uuml;lc&uuml;
- */
-public class StaticMDCBinder {
-
-    /**
-     * The unique instance of this class.
-     */
-    public static final StaticMDCBinder SINGLETON = new StaticMDCBinder();
-
-    private StaticMDCBinder() {
-    }
-
-    /**
-     * Return the singleton of this class.
-     * 
-     * @return the StaticMDCBinder singleton
-     * @since 1.7.14
-     */
-    public static final StaticMDCBinder getSingleton() {
-        return SINGLETON;
-    }
-
-    /**
-     * Currently this method always returns an instance of 
-     * {@link BasicMDCAdapter}.
-     */
-    public MDCAdapter getMDCA() {
-        // note that this method is invoked only from within the static initializer of
-        // the org.slf4j.MDC class.
-        return new BasicMDCAdapter();
-    }
-
-    public String getMDCAdapterClassStr() {
-        return BasicMDCAdapter.class.getName();
-    }
-}
diff --git a/slf4j/src/main/java/org/slf4j/impl/StaticMarkerBinder.java b/slf4j/src/main/java/org/slf4j/impl/StaticMarkerBinder.java
deleted file mode 100644
index 21a48df6..00000000
--- a/slf4j/src/main/java/org/slf4j/impl/StaticMarkerBinder.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Copyright (c) 2004-2011 QOS.ch
- * All rights reserved.
- *
- * Permission is hereby granted, free  of charge, to any person obtaining
- * a  copy  of this  software  and  associated  documentation files  (the
- * "Software"), to  deal in  the Software without  restriction, including
- * without limitation  the rights to  use, copy, modify,  merge, publish,
- * distribute,  sublicense, and/or sell  copies of  the Software,  and to
- * permit persons to whom the Software  is furnished to do so, subject to
- * the following conditions:
- *
- * The  above  copyright  notice  and  this permission  notice  shall  be
- * included in all copies or substantial portions of the Software.
- *
- * THE  SOFTWARE IS  PROVIDED  "AS  IS", WITHOUT  WARRANTY  OF ANY  KIND,
- * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF
- * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-package org.slf4j.impl;
-
-import org.slf4j.IMarkerFactory;
-import org.slf4j.MarkerFactory;
-import org.slf4j.helpers.BasicMarkerFactory;
-import org.slf4j.spi.MarkerFactoryBinder;
-
-/**
- * 
- * The binding of {@link MarkerFactory} class with an actual instance of 
- * {@link IMarkerFactory} is performed using information returned by this class. 
- * 
- * @author Ceki G&uuml;lc&uuml;
- */
-public class StaticMarkerBinder implements MarkerFactoryBinder {
-
-    /**
-     * The unique instance of this class.
-     */
-    public static final StaticMarkerBinder SINGLETON = new StaticMarkerBinder();
-
-    final IMarkerFactory markerFactory = new BasicMarkerFactory();
-
-    private StaticMarkerBinder() {
-    }
-
-    /**
-     * Return the singleton of this class.
-     * 
-     * @return the StaticMarkerBinder singleton
-     * @since 1.7.14
-     */
-    public static StaticMarkerBinder getSingleton() {
-        return SINGLETON;
-    }
-
-    /**
-     * Currently this method always returns an instance of 
-     * {@link BasicMarkerFactory}.
-     */
-    public IMarkerFactory getMarkerFactory() {
-        return markerFactory;
-    }
-
-    /**
-     * Currently, this method returns the class name of
-     * {@link BasicMarkerFactory}.
-     */
-    public String getMarkerFactoryClassStr() {
-        return BasicMarkerFactory.class.getName();
-    }
-
-}
-- 
2.45.2.windows.1

